File,Comment,Code,Coherent
VMInformation.java,/** * @{inheritDoc */,"@Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }",1
VMInstanceRequest.java,/** * @param ami */,"public void setInstanceDescription(InstanceDescription description) {
        this.items.put(TankConstants.KEY_DESCRIPTION, description);
    }",1
VMInstanceRequest.java,/** * * @return */,"public boolean getReuseStoppedInstance() {
        Boolean result = (Boolean) this.items.get(TankConstants.KEY_REUSE_STOPPED_INSTANCE);
        return result != null ? result : false;
    }",1
VMInstanceRequest.java,/** * Set the job id * * @param data *            The job id */,"public void setLoggingProfile(String data) {
        this.items.put(TankConstants.KEY_LOGGING_PROFILE, data);
    }",1
VMInstanceRequest.java,/** * Get the job id * * @return The job id */,"public String getStopBehavior() {
        return (String) this.items.get(TankConstants.KEY_STOP_BEHAVIOR);
    }",1
VMInstanceRequest.java,/** * Get the image type * * @return The image type */,"public VMImageType getImage() {
        return (VMImageType) this.items.get(TankConstants.KEY_IMAGE);
    }",1
VMJobRequest.java,/** * Set the job id * * @param data *            The job id */,"public void setStopBehavior(String data) {
        this.items.put(TankConstants.KEY_STOP_BEHAVIOR, data);
    }",1
VMJobRequest.java,/** * Get the number of instances requested * * @return The number of instances requested */,"public int getNumberOfUsers() {
        if (!this.items.containsKey(TankConstants.KEY_NUMBER_OF_USERS)) {
            return -1;
        }
        return Integer.valueOf((String) this.items.get(TankConstants.KEY_NUMBER_OF_USERS));
    }",1
VMJobRequest.java,/** * * @return */,"public String getReportingMode() {
        return (String) this.items.get(TankConstants.KEY_REPORTING_MODE);
    }",1
VMKillRequest.java,/** * Get the list of instance ids * * @return The list of instance ids */,"@SuppressWarnings(""unchecked"")
    public List<String> getInstances() {
        return (List<String>) this.items.get(""instances"");
    }",1
VMLaunchOptions.java,/** * Launches a virtual machine based on the current contents of this set of VM launch options. * @param provider the cloud provider in which the VM should be provisioned * @return the unique ID of the provisioned virtual machine * @throws CloudException an error occurred within the cloud provider while building the VM * @throws InternalException an error occurred within Dasein Cloud in preparing the API call * @throws OperationNotSupportedException the cloud does not support virtual machines */,"public @Nonnull String build(@Nonnull CloudProvider provider) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + "" does not support compute services."");
        }",1
VMLaunchOptions.java,/** * Launches multiple virtual machines based on the current contents of this set of launch options. The method is a success * if any one virtual machine is provisioned even if any errors occurred provisioning others. * @param provider the cloud provider in which the VM should be provisioned * @param count the number of virtual machines to provision * @return the IDs of the virtual machines that were provisioned * @throws CloudException an error occurred within the cloud provider that prevented the provisioning of any VMs * @throws InternalException an error occurred within Dasein Cloud in preparing the API call (can happen even if a VM gets provisioned) * @throws OperationNotSupportedException the cloud does not support virtual machines */,"public @Nonnull Iterable<String> buildMany(@Nonnull CloudProvider provider, int count) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + "" does not support compute services."");
        }",1
VMLaunchOptions.java,/** * Indicates which firewalls this configuration will support. This call adds to any configured firewall IDs. * You can therefore call it multiple times if it makes sense to your code logic. * @param firewallIds one or more firewall IDs to protect the new VM * @return this */,"public @Nonnull VMLaunchOptions behindFirewalls(@Nonnull String ... firewallIds) {
        if( this.firewallIds == null || this.firewallIds.length < 1 ) {
            this.firewallIds = firewallIds;
        }",1
VMLaunchOptions.java,"/** * Identifies a specific, existing volume to attach post-launch. This call is accretive, meaning that you can * call it multiple times to add additional volumes (order matters) * @param existingVolumeId the cloud provider volume ID for the volume to attach * @param withDeviceId the device ID to use in making the attachment * @return this */","public @Nonnull VMLaunchOptions withAttachment(@Nonnull String existingVolumeId, @Nonnull String withDeviceId) {
        VolumeAttachment a = new VolumeAttachment();
        
        a.deviceId = withDeviceId;
        a.existingVolumeId = existingVolumeId;
        if( volumes == null || volumes.length < 1 ) {
            volumes = new VolumeAttachment[] { a };
        }",1
VMLaunchOptions.java,"/** * Indicates the network interfaces to be attached to this virtual machine at launch time. This method is accretive, * meaning it will add to any existing network interface configurations. * @param nicIds the unique cloud provider IDs for the network interfaces to be attached * @return this */","public @Nonnull VMLaunchOptions withNetworkInterfaces(String ... nicIds) {
        if( networkInterfaces == null || networkInterfaces.length < 1 ) {
            int i = 0;
            
            networkInterfaces = new NICConfig[nicIds.length];
            for( String id : nicIds ) {
                NICConfig cfg = new NICConfig();
                
                cfg.nicId = id;
                networkInterfaces[i++] = cfg;
            }
        }",1
VMNodeBean.java,/** * @{inheritDoc */,"@Override
    public String getType() {
        return ""vm"";
    }",1
VMPCRandomGenerator.java,/** * Value generated in the same way as {@link VMPCRandomGenerator#P}; */,"private byte s = (byte) 0xbe;

    public VMPCRandomGenerator()
    {
    }",1
VmstaxServiceImpl.java,/** * @param p_oContent * @param p_sFormat * @param p_sFileName * @return * @throws IOException * @throws VmstaxParseException * @throws Exception */,"private List<VmstaxData> parseLogFile(byte[] p_oContent, String p_sFormat,
			String p_sFileName, VmstaxContext p_oVmstaxContext ) throws IOException, VmstaxParseException,
			Exception {

		InputStream oIs = new ByteArrayInputStream(p_oContent);
		List<String> listLines = null;
		try {
			listLines = IOUtils.readLines(oIs);
		} finally {
			oIs.close();
		}

		List<VmstaxData> r_listVmstaxData = new ArrayList<VmstaxData>();
		VmstaxParser oVmstaxParser = (VmstaxParser) this.vmstaxParsers
				.get(p_sFormat);
		if (oVmstaxParser != null) {
			r_listVmstaxData.addAll(oVmstaxParser.parse(listLines, p_oVmstaxContext));
			for( VmstaxData oVmstaxData : r_listVmstaxData ) {
				oVmstaxData.setFileName(p_sFileName);
			}
		} else {
			throw new Exception(""Can't find parser for format : "" + p_sFormat);
		}

		return r_listVmstaxData;
	}",1
VmstaxServiceImpl.java,/** * @param parsers */,"public void setParsers(List<VmstaxParser> parsers) {
		this.parsers = parsers;
	}",1
VMTrackerImpl.java,/** * @{inheritDoc */,"@Override
    public void publishEvent(JobEvent event) {
        try {
            jobEventProducer.fire(event);
        } catch (Exception e) {
            LOG.error(""Error firing Event: "" + e, e);
        }
    }",1
VMTrackerImpl.java,/** * @param status * @return */,"private JobQueueStatus getQueueStatus(JobQueueStatus oldStatus, JobStatus jobSatatus) {
        try {
            return JobQueueStatus.valueOf(jobSatatus.name());
        } catch (Exception e) {
            LOG.error(""Error converting status from "" + jobSatatus);
        }
        return oldStatus;
    }",1
VMTrackerImpl.java,/** * * @{inheritDoc */,"@Override
    public void removeStatusForInstance(String instanceId) {
        statusMap.remove(instanceId);
    }",1
VMTrackerImpl.java,/** * @{inheritDoc */,"@Override
    public CloudVmStatusContainer getVmStatusForJob(String jobId) {
        return jobMap.get(jobId);
    }",1
VMTrackerImpl.java,/** * @param jobId * @return */,"private JobInstance getJob(String jobId) {
        JobInstanceDao dao = new JobInstanceDao();
        JobInstance job = null;
        try {
            int id = Integer.parseInt(jobId);
            job = dao.findById(id);
        } catch (NumberFormatException e) {
            // dev mode. using synthetic jobID
            LOG.warn(""Using Local mode ignoring job status."");
        }
        return job;
    }",1
VMUpdateStateRequest.java,/** * Constructor * * @param provider *            The virtual machine environment * @param region *            The region for the virtual machine * @param size *            The size of the virtual machine */,"public VMUpdateStateRequest(VMProvider provider, String instanceId) {
        super(provider);
        String[] instances = new String[] { instanceId };
        this.setInstances(instances);
    }",1
VMUpdateStateRequest.java,/** * Get the array of instance ids * * @return The array of instance ids */,"public String[] getInstances() {
        return (String[]) this.items.get(""instances"");
    }",1
VMWareExecutorConfiguration.java,/** * @param rootDir * @param propNames */,"public VMWareExecutorConfiguration(File rootDir, String[] propNames) {
		super(rootDir, propNames);
	}",1
VncCanvas.java,"/** * Warp the mouse to x, y in the RFB coordinates * @param x * @param y */","void warpMouse(int x, int y)
	{
		bitmapData.invalidateMousePosition();
		mouseX=x;
		mouseY=y;
		bitmapData.invalidateMousePosition();
		try
		{
			rfb.writePointerEvent(x, y, 0, MOUSE_BUTTON_NONE);
		}
		catch ( IOException ioe)
		{
			Log.w(TAG,ioe);
		}
	}",1
VncCanvas.java,"/** * Convert a motion event to a format suitable for sending over the wire * @param evt motion event; x and y must already have been converted from screen coordinates * to remote frame buffer coordinates. * @param downEvent True if ""mouse button"" (touch or trackball button) is down when this happens * @param useRightButton If true, event is interpreted as happening with right mouse button * @return true if event was actually sent */","public boolean processPointerEvent(MotionEvent evt,boolean downEvent,boolean useRightButton) {
		return processPointerEvent((int)evt.getX(),(int)evt.getY(), evt.getAction(), evt.getMetaState(), downEvent, useRightButton);
	}",1
VnfmSpringHelper.java,"/** * This method should be used for receiving text message from EMS * * <p>resp = { 'output': out, // the output of the command 'err': err, // the error outputs of the * commands 'status': status // the exit status of the command } * * @param queueName * @return * @throws JMSException */","public String receiveTextFromQueue(String queueName)
      throws JMSException, ExecutionException, InterruptedException, VnfmSdkException {
    String res;

    Connection connection = connectionFactory.createConnection();
    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    MessageConsumer consumer = session.createConsumer(session.createQueue(queueName));
    connection.start();
    String scriptMaxTime = properties.getProperty(""script-max-time"");
    if (scriptMaxTime != null) {
      TextMessage textMessage = (TextMessage) consumer.receive(Long.parseLong(scriptMaxTime));
      if (textMessage != null) res = textMessage.getText();
      else
        throw new VnfmSdkException(
            ""No message got from queue "" + queueName + "" after "" + scriptMaxTime);
    } else res = ((TextMessage) consumer.receive()).getText();
    log.debug(""Received Text from "" + queueName + "": "" + res);
    consumer.close();
    session.close();
    connection.close();
    return res;
  }",1
VocabularyService.java,"/** * @summary Perform a lookup of an array of concept identifiers returning the * matching concepts with their detailed properties, using the default source. * @param identifiers an array of concept identifiers * @return collection of concepts */","@Path(""lookup/identifiers"")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeIdentifierLookup(long[] identifiers) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception(""No vocabulary or cdm daimon was found in configured sources.  Search failed.""), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeIdentifierLookup(defaultSourceKey, identifiers);   
  }",1
VocabularyService.java,/** * @summary Lookup source codes in the specified vocabulary using the default source. * @param sourcecodes array of source codes * @return collection of concepts */,"@Path(""lookup/sourcecodes"")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSourcecodeLookup(String[] sourcecodes) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception(""No vocabulary or cdm daimon was found in configured sources.  Search failed.""), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeSourcecodeLookup(defaultSourceKey, sourcecodes);
  }",1
VocabularyService.java,/** * @summary find all concepts mapped to the identifiers provided * @param sourceKey path parameter specifying the source key identifying the * source to use for access to the set of vocabulary tables * @param identifiers an array of concept identifiers * @return collection of concepts */,"@Path(""{sourceKey}/lookup/mapped"")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeMappedLookup(@PathParam(""sourceKey"") String sourceKey, long[] identifiers) {
    if (identifiers.length == 0) {
      return new ArrayList<>();
    }",1
VocabularyService.java,/** * Perform a search using the default vocabulary source. * @param search * @return */,"@Path(""search"")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSearch(ConceptSearch search) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception(""No vocabulary or cdm daimon was found in configured sources.  Search failed.""), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeSearch(defaultSourceKey, search);    
  }",1
VOffset.java,/** * Move text vertically by N pixels * * @param pixels the number of pixels */,"public VOffset(String pixels) throws ParseException {
        try {
            this.mPixels = Integer.parseInt(pixels);
        } catch (NumberFormatException e) {
            throw new ParseException(String.format(""Invalid pixels: '%s'"", pixels));
        }
    }",1
VOGeoServerContrastEnhancementNormalizeBlueTest.java,/** * Creates the channel selection error object. * * @param styleFactory the style factory * @param contrastMethod the contrast method * @return the channel selection */,"private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = 
                (ContrastEnhancement) styleFactory.contrastEnhancement(null, 
                contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put(""algorithm"", ff.literal(""TestStretchToMinimumMaximum""));
        options.put(""minValue"", ff.literal(""1.0""));
        options.put(""maxValue"", ff.literal(""5.0""));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType(""channel name"",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }",1
VOGeoServerContrastEnhancementNormalizeGreenTest.java,/** * Creates the channel selection error object. * * @param styleFactory the style factory * @param contrastMethod the contrast method * @return the channel selection */,"private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put(""algorithm"", ff.literal(""TestStretchToMinimumMaximum""));
        options.put(""minValue"", ff.literal(""1.0""));
        options.put(""maxValue"", ff.literal(""5.0""));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType(""channel name"",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }",1
VOGeoServerContrastEnhancementNormalizeGreyTest.java,/** * Creates the channel selection error object. * * @param styleFactory the style factory * @param contrastMethod the contrast method * @return the channel selection */,"private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put(""algorithm"", ff.literal(""TestStretchToMinimumMaximum""));
        options.put(""minValue"", ff.literal(""1.0""));
        options.put(""maxValue"", ff.literal(""5.0""));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType(""channel name"",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }",1
VoiceCommands.java,/** * Fire an intent to start the voice recognition activity. */,"private void startVoiceRecognitionActivity() {
        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, ""Voice recognition test..."");
        startActivityForResult(intent, REQUEST_CODE);

    }",1
VoiceFirebaseInstanceIDService.java,/** * Persist token to third-party servers. * * Modify this method to associate the user's FCM InstanceID token with any server-side account * maintained by your application. * * @param token The new token. */,"private void sendRegistrationToServer(String token) {
        // TODO: Implement this method to send token to your app server.
    }",1
VoidElementTest.java,"/** * Voids of size 2 to 9 should be all header, no body */","@Test
  public void test2To9()
  {
    for (int i = 2; i < 10; ++i)
    {
      VoidElement voidz = new VoidElement(i);
      MockWriter mw = new MockWriter();
      voidz.writeElement(mw);
      Assert.assertEquals(i, mw.getBuff().position());
    }
  }",1
VoidValueReader.java,/** * {@inheritDoc} */,"@Override
	public Void read(InputStream inputStream) throws IOException {
		final String content = IOUtils.toString(inputStream, ENCODING);
		log.debug(""Parsing: {}"", content);

		return null;
	}",1
VoldemortClient.java,"/** * Initialize the DB layer. This accepts all properties allowed by the Voldemort client. * A store maps to a table. * Required : bootstrap_urls * Additional property : store_name -> to preload once, should be same as -t <table> * * {@linktourl http://project-voldemort.com/javadoc/client/voldemort/client/ClientConfig.html} */","public void init() throws DBException {
		ClientConfig clientConfig = new ClientConfig(getProperties());
		socketFactory = new SocketStoreClientFactory(clientConfig);
		
		// Retrieve store name
		storeName = getProperties().getProperty(""store_name"", ""usertable"");
		
		// Use store name to retrieve client
		storeClient = socketFactory.getStoreClient(storeName);
		if ( storeClient == null )
			throw new DBException(""Unable to instantiate store client"");
		
	}",1
VoldPeers.java,/** * Construct new list of peers for deletion of a node * * @param uuid * @param peers * @param returnList * @return */,"private final static VoldLocation constructNewPeersListForDel(@Nonnull final UUID uuid,
            final List<VoldLocation> peers, final List<VoldLocation> returnList) {
        final List<VoldLocation> newPeers = new ArrayList<VoldLocation>();
        VoldLocation nodeToRemove = null;
        if (peers != null) {
            for (final VoldLocation oldLocation : peers) {
                if (oldLocation.getNode().equals(uuid)) {
                    // Node to remove
                    nodeToRemove = new VoldLocation(oldLocation.getNode(), oldLocation.getSockAddr());
                }
                else {
                    newPeers.add(oldLocation);
                }
            }
        }
        returnList.clear();
        returnList.addAll(newPeers);
        return nodeToRemove;
    }",1
VoldPeers.java,/** * Check port range according to RFC6335 * * @see http://tools.ietf.org/html/rfc6335#section-8.1 * * @param port */,"private static void checkPortRange(final int port) {
        if (port < 0 || port > 65535) {
            throw new IllegalArgumentException(""Port="" + port + "" is not in [0-65535] range!"");
        }
        if (port < 1024) {
            throw new IllegalArgumentException(""Can not use port="" + port + "" in [0-1024] system range!"");
        }
    }",1
VoldPeers.java,/** * Remove a peer from the {@link Vold}. * * @param peer * @throws JMException * @return The {@link UUID} of the task handling the operation as a String */,"final String removePeerNoWait(final String uuid, final DtxTaskApi dtxTaskApi) throws JMException {
        // 1) check parameters
        Objects.requireNonNull(uuid, ""Uuid parameter not provided !"");
        final UUID node = UUID.fromString(uuid);
        final VoldLocation localPeer = vold.getVoldLocation();
        if (UUID.fromString(uuid) == localPeer.getNode()) {
            LOGGER.debug(""Will remove local peer='"" + uuid + ""' !"");
        }

        // 2) Submit transaction
        if (dtxTaskApi == null) {
            throw new IllegalArgumentException(""Can't start transaction without DTX manager !"");
        }
        return submitRemovePeerTaskNoWait(node, dtxTaskApi).toString();
    }",1
VoldPeers.java,/** * Wait for a task end. * * @param taskId */,"private final void waitTaskEnd(@Nonnull final UUID taskId, @Nonnull final DtxTaskApi dtxTaskApi) {

        // Wait for task end
        final DtxTaskFutureVoid future = new DtxTaskFutureVoid(taskId, dtxTaskApi);
        try {
            future.get();
        }",1
Volley.java,"/** * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it. * * @param context A {@link Context} to use for creating the cache dir. * @param stack An {@link HttpStack} to use for the network, or null for default. * @return A started {@link RequestQueue} instance. */","public static RequestQueue newRequestQueue(Context context, HttpStack stack)
    {
    	return newRequestQueue(context, stack, -1);
    }",1
VolleyBall.java,"/** * Creates a default instance of the worker pool and calls {@link com.android.volley.RequestQueue#start()} on it. * * @param context A {@link android.content.Context} to use for creating the cache dir. * @param stack An {@link com.android.volley.toolbox.HttpStack} to use for the network, or null for default. * @return A started {@link com.android.volley.RequestQueue} instance. */","public static BallRequestQueue newRequestQueue(Context context, HttpStack stack) {
        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);

        String userAgent = ""volley/0"";
        try {
            String packageName = context.getPackageName();
            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
            userAgent = packageName + ""/"" + info.versionCode;
        } catch (NameNotFoundException e) {
        }

        if (stack == null) {
            if (Build.VERSION.SDK_INT >= 9) {
                stack = new HurlStack();
            } else {
                // Prior to Gingerbread, HttpUrlConnection was unreliable.
                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
            }
        }

        Network network = new BasicNetwork(stack);

        BallRequestQueue queue = new BallRequestQueue(new DiskBasedCache(cacheDir), network);
        queue.start();

        return queue;
    }",1
VolleyImageUtils.java,"/** * compress the image file, create a scaled compressed image file, and overwrite the origin one. * @param path  origin image file path * @param maxWidth * @param maxHeight * @param quality */","public static void compress(String originPath, String outputPath, int maxWidth, int maxHeight, int quality) {
        FileOutputStream out;
        try {
            Bitmap scaledBitmap = getScaledBitmap(originPath, maxWidth, maxHeight);
            Bitmap rotatedBitmap = rotateBitmap(getBitmapDegree(originPath), scaledBitmap);
            out = new FileOutputStream(outputPath);
            Bitmap mutableBitmap = rotatedBitmap.copy(Bitmap.Config.ARGB_8888, true);

            // write the compressed bitmap at the destination specified by filename.
            mutableBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }",1
Volta.java,"/** * Gets the index of the measure, where this volta ends (inclusive). */","public int getEndMeasureIndex() {
		return getMP().measure + length - 1;
	}",1
VoltageDecryptor.java,/** * @param dataIn * @param format * @return returns java.lang.String * @throws FaultResponse */,"@Override
    public String accessFormattedData(String dataIn, String format) throws FaultResponse {
        return service.accessFormattedData(dataIn, format, IDENTITY, """", com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }",1
VoltaGroup.java,"/** * Gets the number of repetitions. * See {@link Volta} for the playback rules. * Notice, that the actual playback could be different, * e.g. when a volta contains a jump (e.g. coda) to another * measure. */","public int getRepeatCount() {
		//find maximum repeat number (+1, if the last volta is a default volta)
		int maxRepeatTime = 0;
		for (val v : voltasStartMeasures) {
			if (false == v.volta.isDefault())
				maxRepeatTime = max(maxRepeatTime, v.volta.getNumbers().getStop());
			else
				maxRepeatTime = max(maxRepeatTime, 1); //enter default volta at least one time
		}
		if (voltasStartMeasures.size() > 1 && //when there is at least one other volta before a final default volta
				voltasStartMeasures.getLast().volta.isDefault()) {
			maxRepeatTime += 1;
		}
		return maxRepeatTime;
	}",1
VolumeCreateOptions.java,/** * Provisions a volume in the specified cloud based on the options defined in this object. * @param provider the cloud provider in which the volume should be provisioned * @return the unique ID of the newly provisioned volume * @throws CloudException an error occurred with the cloud provider while provisioning the volume * @throws InternalException an error occurred within Dasein Cloud while preparing the API call * @throws OperationNotSupportedException the cloud does not support volumes */,"public @Nonnull String build(@Nonnull CloudProvider provider) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + "" does not have support for compute services"");
        }",1
VolumeDialog.java,/** * Provides access to the seek bar * @return VolumeDialog's SeekBar */,"public SeekBar volumeBar(){
		return (SeekBar)findViewById(R.id.volume_seek);
	}",1
VolumeFilterOptions.java,/** * Indicates whether these options can match a single criterion (<code>true</code>) or if all criteria must be * matched in order for the volume to pass the filter (<code>false</code>). * @return whether matching any single criterion is sufficient to consider a volume a match */,"public boolean isMatchesAny() {
        return matchesAny;
    }",1
VomsAuthorisationStrategy.java,/** * @return the usersDN */,"public List<String> getUsersDN() {
			return usersDN;
		}",1
VOMSMessages.java,/** * @param workerProviderClientID * @param requestId * @return */,"public static String getNonAuthorisedConsumerMessage(String workerProviderClientContainerID, long requestId) {
		return ""Request ""+requestId+"": request ignored because [""+ workerProviderClientContainerID + ""] "" +
				"" is not authorized at VOMS."";
	}",1
VOMSMessages.java,/** * @return */,"public static String getNullVOMSUrlMessage() {
		return ""Property "" + PeerConfiguration.PROP_VOMS_URL + "" should not be null."";
	}",1
VorbisCommentChapter.java,"/** * Get the string that comes after 'CHAPTERxxx', for example 'name' or * 'url'. */","public static String getAttributeTypeFromKey(String key) {
        if (key.length() > CHAPTERXXX_LENGTH) {
            return key.substring(CHAPTERXXX_LENGTH, key.length());
        }
        return null;
    }",1
VorbisCommentReader.java,"/** * Looks for an identification header in the first page of the file. If an * identification header is found, it will be skipped completely and the * method will return true, otherwise false. * * @throws IOException */","private boolean findIdentificationHeader(InputStream input)
            throws IOException {
        byte[] buffer = new byte[FIRST_PAGE_LENGTH];
        IOUtils.readFully(input, buffer);
        int i;
        for (i = 6; i < buffer.length; i++) {
            if (buffer[i - 5] == 'v' && buffer[i - 4] == 'o'
                    && buffer[i - 3] == 'r' && buffer[i - 2] == 'b'
                    && buffer[i - 1] == 'i' && buffer[i] == 's'
                    && buffer[i - 6] == PACKET_TYPE_IDENTIFICATION) {
                return true;
            }
        }
        return false;
    }",1
VPNConnectionState.java,/** * Represents the current state of a connection between a cloud VPN and a physical VPN gateway. * <p>Created by George Reese: 6/26/12 2:48 PM</p> * @author George Reese (george.reese@imaginary.com) * @since 2012-07 * @version 2012-07 initial version */,"public enum VPNConnectionState {
    PENDING, AVAILABLE, DELETING, DELETED
}",1
VPNPayload.java,/** * An MDM payload for VPN. * * @author Sylvain Pedneault */,"class VPNPayload extends MobileConfigPayload {
  public static final String VPNTYPE_L2TP = ""L2TP"";
  public static final String VPNTYPE_PPTP = ""PPTP"";
  public static final String VPNTYPE_IP_SEC = ""IPSec"";

  public VPNPayload(final int payloadVersion, final String payloadOrganization, final String payloadIdentifier, final String payloadDisplayName, final String userDefinedName, final boolean overridePrimary, final String vpnType) throws JSONException {
    super(payloadVersion, ""com.apple.vpn.managed"", payloadOrganization, payloadIdentifier, payloadDisplayName);
    final JSONObject payload = getPayload();
    payload.put(""UserDefinedName"", userDefinedName);
    payload.put(""OverridePrimary"", overridePrimary);
    payload.put(""VPNType"", vpnType);
  }

  public JSONObject addPPP() throws JSONException {
    final JSONObject object = new JSONObject();
    getPayload().put(""PPP"", object);
    return object;
  }

  public JSONObject addIPSec() throws JSONException {
    final JSONObject object = new JSONObject();
    getPayload().put(""IPSec"", object);
    return object;
  }
}",1
VpnProfileDataSource.java,/** * Close the data source. */,"public void close()
	{
		if (mDbHelper != null)
		{
			mDbHelper.close();
			mDbHelper = null;
		}
	}",1
VpnProfileDataSource.java,"/** * Insert the given VPN profile into the database.  On success the Id of * the object is updated and the object returned. * * @param profile the profile to add * @return the added VPN profile or null, if failed */","public VpnProfile insertProfile(VpnProfile profile)
	{
		ContentValues values = ContentValuesFromVpnProfile(profile);
		long insertId = mDatabase.insert(TABLE_VPNPROFILE, null, values);
		if (insertId == -1)
		{
			return null;
		}
		profile.setId(insertId);
		return profile;
	}",1
VpnProfileDetailActivity.java,/** * Update the UI to enter credentials depending on the type of VPN currently selected */,"private void updateCredentialView()
	{
		mUsernamePassword.setVisibility(mVpnType.has(VpnTypeFeature.USER_PASS) ? View.VISIBLE : View.GONE);
		mUserCertificate.setVisibility(mVpnType.has(VpnTypeFeature.CERTIFICATE) ? View.VISIBLE : View.GONE);
		mTncNotice.setVisibility(mVpnType.has(VpnTypeFeature.BYOD) ? View.VISIBLE : View.GONE);

		if (mVpnType.has(VpnTypeFeature.CERTIFICATE))
		{
			if (mUserCertLoading != null)
			{
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(mUserCertLoading);
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(R.string.loading);
			}
			else if (mUserCertEntry != null)
			{	/* clear any errors and set the new data */
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setError(null);
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(mUserCertEntry.getAlias());
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(mUserCertEntry.getCertificate().getSubjectDN().toString());
			}
			else
			{
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(R.string.profile_user_select_certificate_label);
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(R.string.profile_user_select_certificate);
			}
		}
	}",1
VpnProfileDetailActivity.java,/** * Update the CA certificate selection UI depending on whether the * certificate should be automatically selected or not. */,"private void updateCertificateSelector()
	{
		if (!mCheckAuto.isChecked())
		{
			mSelectCert.setEnabled(true);
			mSelectCert.setVisibility(View.VISIBLE);

			if (mCertEntry != null)
			{
				((TextView)mSelectCert.findViewById(android.R.id.text1)).setText(mCertEntry.getSubjectPrimary());
				((TextView)mSelectCert.findViewById(android.R.id.text2)).setText(mCertEntry.getSubjectSecondary());
			}
			else
			{
				((TextView)mSelectCert.findViewById(android.R.id.text1)).setText(R.string.profile_ca_select_certificate_label);
				((TextView)mSelectCert.findViewById(android.R.id.text2)).setText(R.string.profile_ca_select_certificate);
			}
		}
		else
		{
			mSelectCert.setEnabled(false);
			mSelectCert.setVisibility(View.GONE);
		}
	}",1
VpnProfileDetailActivity.java,/** * Update the profile object with the data entered by the user */,"private void updateProfileData()
	{
		/* the name is optional, we default to the gateway if none is given */
		String name = mName.getText().toString().trim();
		String gateway = mGateway.getText().toString().trim();
		mProfile.setName(name.isEmpty() ? gateway : name);
		mProfile.setGateway(gateway);
		mProfile.setVpnType(mVpnType);
		if (mVpnType.has(VpnTypeFeature.USER_PASS))
		{
			mProfile.setUsername(mUsername.getText().toString().trim());
			String password = mPassword.getText().toString().trim();
			password = password.isEmpty() ? null : password;
			mProfile.setPassword(password);
		}
		if (mVpnType.has(VpnTypeFeature.CERTIFICATE))
		{
			mProfile.setUserCertificateAlias(mUserCertEntry.getAlias());
		}
		String certAlias = mCheckAuto.isChecked() ? null : mCertEntry.getAlias();
		mProfile.setCertificateAlias(certAlias);
	}",1
VpnService.java,/** * Returns the daemons management class for this service object. */,"protected VpnDaemons getDaemons() {
        return mDaemons;
    }",1
VpnService.java,/** * Returns the VPN profile associated with the connection. */,"protected E getProfile() {
        return mProfile;
    }",1
VpnStateService.java,/** * Unregister a listener from this Service. * * @param listener listener to unregister */,"public void unregisterListener(VpnStateListener listener)
	{
		mListeners.remove(listener);
	}",1
VpnStateService.java,"/** * Get the current IMC state, if any. * * @return imc state */","public ImcState getImcState()
	{	/* only updated from the main thread so no synchronization needed */
		return mImcState;
	}",1
VpnStateService.java,"/** * Get the remediation instructions, if any. * * @return read-only list of instructions */","public List<RemediationInstruction> getRemediationInstructions()
	{	/* only updated from the main thread so no synchronization needed */
		return Collections.unmodifiableList(mRemediationInstructions);
	}",1
VpnStateService.java,/** * Add the given remediation instruction to the internal list.  Listeners * are not notified. * * Instructions are cleared if the IMC state is set to UNKNOWN. * * May be called from threads other than the main thread. * * @param instruction remediation instruction */,"public void addRemediationInstruction(final RemediationInstruction instruction)
	{
		mHandler.post(new Runnable() {
			@Override
			public void run()
			{
				VpnStateService.this.mRemediationInstructions.add(instruction);
			}
		});
	}",1
VRDeepLinkHelper.java,/** * Checks whether any of the support oculus app is installed. * * @param context an android context * @param packageName an android app package name * @return whether an app with the given package name is installed */,"@VisibleForTesting
  static boolean hasAppInstalled(Context context, String packageName) {
    try {
      context.getPackageManager().getPackageInfo(packageName, 0);
      return true;
    } catch (PackageManager.NameNotFoundException e) {
      return false;
    }
  }",1
VSphere.java,/** * @param vmName - name of VM object to retrieve * @return - VirtualMachine object * @throws VSphereException If an error occurred. */,"public VirtualMachine getVmByName(String vmName) throws VSphereException {
		try {
			return (VirtualMachine) new InventoryNavigator(
					getServiceInstance().getRootFolder()).searchManagedEntity(
							""VirtualMachine"", vmName);
		} catch (Exception e) {
			throw new VSphereException(e);
		}
	}",1
VSphere.java,/** * Find Distributed Virtual Port Group name in the same Datacenter as the VM * @param virtualMachine - VM object * @param name - the name of the Port Group * @return returns DistributedVirtualPortgroup object for the provided vDS PortGroup * @throws VSphereException If an error occurred. */,"public Network getNetworkPortGroupByName(VirtualMachine virtualMachine,
														String name) throws VSphereException
	{
		try {
			Datacenter datacenter = getDataCenter(virtualMachine);
			for (Network network : datacenter.getNetworks())
			{
				if (network instanceof Network &&
						(name.isEmpty() || network.getName().contentEquals(name)))
				{
					return network;
				}
			}
		} catch (Exception e) {
			throw new VSphereException(e);
		}
		return null;
	}",1
VSphere.java,/** * Find Distributed Virtual Switch from the provided Distributed Virtual Portgroup * @param distributedVirtualPortgroup - DistributedVirtualPortgroup object for the provided vDS PortGroup * @return returns DistributedVirtualSwitch object that represents the vDS Switch * @throws VSphereException If an error occurred. */,"public DistributedVirtualSwitch getDistributedVirtualSwitchByPortGroup(
			DistributedVirtualPortgroup distributedVirtualPortgroup) throws VSphereException
	{
		try
		{
			ManagedObjectReference managedObjectReference = new ManagedObjectReference();
			managedObjectReference.setType(""DistributedVirtualSwitch"");
			managedObjectReference.setVal(distributedVirtualPortgroup.getConfig().getDistributedVirtualSwitch().getVal());
			return new DistributedVirtualSwitch(getServiceInstance().getServerConnection(), managedObjectReference);
		}
		catch (Exception e)
		{
			throw new VSphereException(e);
		}
	}",1
VSphere.java,"/** * Passes data to a VM's ""guestinfo"" object. This data can then be read by * the VMware Tools on the guest. * <p> * e.g. a variable named ""Foo"" with value ""Bar"" could be read on the guest * using the command-line <tt>vmtoolsd --cmd ""info-get guestinfo.Foo""</tt>. * </p> * * @param vmName *            The name of the VM. * @param variables *            A {@link Map} of variable name to variable value. * @throws VSphereException *             If an error occurred. */","public void addGuestInfoVariable(String vmName, Map<String, String> variables) throws VSphereException {
        VirtualMachineConfigSpec cs = new VirtualMachineConfigSpec();
        OptionValue[] ourOptionValues = new OptionValue[variables.size()];
        List<OptionValue> optionValues = new ArrayList<>();
        for (Map.Entry<String, String> eachVariable : variables.entrySet()) {
            OptionValue ov = new OptionValue();
            ov.setKey(""guestinfo."" + eachVariable.getKey());
            ov.setValue(eachVariable.getValue());
            optionValues.add(ov);
        }
        for (int i = 0; i < optionValues.size(); i++) {
            ourOptionValues[i] = optionValues.get(i);
        }
        cs.setExtraConfig(ourOptionValues);
        reconfigureVm(vmName, cs);
    }",1
VSphere.java,/** * Creates a {@link VSphereException} whose cause is the {@link TaskInfo}'s * exception. This provides an exception that is much more informative than * what is said by the <code>message</code> alone. * * @param taskInfo *            The vSphere task that failed. * @param message *            A line of text that says what the task was trying to achieve. * @return An exception that includes the cause of the failure. */,"private static VSphereException newVSphereException(TaskInfo taskInfo, final String message) {
        final com.vmware.vim25.LocalizedMethodFault error = taskInfo == null ? null : taskInfo.getError();
        final String faultMsg = error == null ? null : error.getLocalizedMessage();
        final Exception fault = error == null ? null : error.getFault();
        final String combinedMsg = message + (faultMsg == null ? """" : (""\n"" + faultMsg));
        if (fault != null) {
            return new VSphereException(combinedMsg, fault);
        } else {
            return new VSphereException(combinedMsg);
        }
    }",1
VSphereScannerTest.java,"/* * @Test public void testCreateSetClause() { VSphereScanner scanner = new * VSphereScanner(); * * String clause = scanner.createSetClause(""x"", mapper.createObjectNode() * .put(""a"", ""1"").put(""foo"", ""bar"")); * * assertThat(clause).contains(""x.a={a}"").contains(""x.foo={foo}"") * .contains("",""); * * } */","@Test
	public void testComputeMacId() {
		ManagedObjectReference mor = new ManagedObjectReference();
		mor.setType(""HostSystem"");
		mor.setVal(""host-123"");

		VMWareScanner s = Mockito.mock(VMWareScanner.class);
		when(s.getVCenterId()).thenReturn(""abcdef"");
		Mockito.when(s.computeUniqueId(mor)).thenCallRealMethod();

		assertThat(mor.getType()).isEqualTo(""HostSystem"");
		assertThat(s.computeUniqueId(mor)).isEqualTo(""21b23eae3d48797d8d057329705825e637e35d81"");

		VMWareScanner s2 = Mockito.mock(VMWareScanner.class);

		when(s2.getVCenterId()).thenReturn(""another"");
		Mockito.when(s2.computeUniqueId(mor)).thenCallRealMethod();
		assertThat(s.computeUniqueId(mor)).isNotEqualTo(s2.computeUniqueId(mor));
		/*
		 * try { new VSphereScanner().computeMacId(null); } catch (Exception e)
		 * { assertThat(e) .isExactlyInstanceOf(NullPointerException.class)
		 * .hasMessageContaining(""cannot be null""); }
		 * 
		 * mor = new ManagedObjectReference(); mor.setType(""VirtualMachine"");
		 * mor.setVal(""vm-123""); try { new VSphereScanner().computeMacId(mor);
		 * fail(); } catch (Exception e) { assertThat(e).isInstanceOf(
		 * IllegalArgumentException.class); }
		 */
	}",1
Vvr.java,/** * Register the snapshots and the devices to the given {@link MBeanServer}. * * @param server * @throws JMException */,"private final void registerElements() throws JMException {
        final UUID vvrUuid = getUuidUuid();

        // Register snapshots
        {
            final Set<UUID> snapshots = vvrInstance.getSnapshots();
            for (final UUID uuid : snapshots) {
                final Snapshot snapshot = vvrInstance.getSnapshot(uuid);
                final VvrSnapshot mbean = new VvrSnapshot(snapshot);
                final ObjectName objectName = VvrObjectNameFactory.newSnapshotObjectName(owner, vvrUuid, uuid);
                server.registerMBean(mbean, objectName);
            }
        }

        // Register devices
        {
            final Set<UUID> devices = vvrInstance.getDevices();
            for (final UUID uuid : devices) {
                final Device device = vvrInstance.getDevice(uuid);
                final VvrDevice mbean = VvrDevice.loadVvrDevice(device, iscsiServer, nbdServer, node);
                devicesMXBeans.put(uuid, new WeakReference<>(mbean));
                final ObjectName objectName = VvrObjectNameFactory.newDeviceObjectName(owner, vvrUuid, uuid);
                server.registerMBean(mbean, objectName);
            }
        }
    }",1
VvrDevice.java,/** * Open the device and create the iSCSI target. * * @param rw *            <code>true</code> to open read-write */,"private final void doActivate(final boolean rw) {
        // TODO create a local task to register target in background after the end of the activation
        try {
            deviceInstance.activate().get();
        }
        catch (InterruptedException | ExecutionException e) {
            // Failed to activate the device
            throw new IllegalStateException(e);
        }
        final ReadWriteHandle rwHandle = deviceInstance.open(rw);

        // Implementation of protocol interface
        protocolDeviceImpl = new ProtocolDeviceImpl(rwHandle, !rw, getIscsiBlockSize());

        // iSCSI target
        final IscsiTarget iScsiTarget = IscsiTarget.newIscsiTarget(getIqn(), getIscsiAlias(), protocolDeviceImpl);
        iscsiServer.addTarget(iScsiTarget);

        // NBD export
        nbdExportName = getName();
        final NbdExport nbdExport = new NbdExport(nbdExportName, protocolDeviceImpl);
        nbdServer.addTarget(nbdExport);
    }",1
VvrDevice.java,/** * Remove the given keys from the device properties. * * @param keys *            property keys */,"private final FutureVoid removeDeviceProperties(final String... keys) {
        return deviceInstance.unsetUserProperties(keys);
    }",1
VvrManager.java,/** * Register a VVR in the MBean server. * * @param vvr *            VVR to register * @throws JMException */,"private final void registerVvrMXBean(final Vvr vvr) throws JMException {
        final ObjectName objectName = VvrObjectNameFactory.newVvrObjectName(owner, vvr.getUuidUuid());
        mbeanServer.registerMBean(vvr, objectName);
        LOGGER.info(""VVR "" + vvr.getUuid() + "" registered"");
    }",1
VvrManager.java,/** * Constructs information for vvr manager task. * * @param operation *            The complete operation used to construct the task info */,"public final DtxTaskInfo createTaskInfo(final RemoteOperation operation) {
        VvrManagerTaskOperation op;
        VvrManagerTargetType targetType;

        final String source = VvrRemoteUtils.fromUuid(operation.getSource()).toString();
        final String targetId = VvrRemoteUtils.fromUuid(operation.getUuid()).toString();

        switch (operation.getType()) {
        case VVR:
            targetType = VvrManagerTargetType.VVR;
            break;
        default:
            throw new AssertionError(""type="" + operation.getType());
        }

        switch (operation.getOp()) {
        case CREATE:
            op = VvrManagerTaskOperation.CREATE;
            break;
        case DELETE:
            op = VvrManagerTaskOperation.DELETE;
            break;
        case START:
            op = VvrManagerTaskOperation.START;
            break;
        case STOP:
            op = VvrManagerTaskOperation.STOP;
            break;
        default:
            throw new AssertionError(""type="" + operation.getOp());
        }
        return new VvrManagerTaskInfo(source, op, targetType, targetId);
    }",1
VvrManagerTaskInfo.java,/** * Gets the target type of the task. May be not be null. * * @return the type of the target */,"public final VvrManagerTargetType getTargetType() {
        return this.targetType;
    }",1
VvrManagerTestUtils.java,"/** * Wait for the apparition of MXBeans. * * @param server *            a dummyMBeanServer * @param nbMXBean *            the wanted number of mx beans * * @return true if there are at least nbMXBean registered MXBeans, otherwise false. */","public final static boolean waitMXBeanNumber(final DummyMBeanServer server, final int nbMXBean)
            throws InterruptedException {
        int i = 0;
        int currentNumber = 0;
        while ((currentNumber = server.getNbMXBeans()) < nbMXBean && i < 100) {
            Thread.sleep(200);
            i++;
        }
        if (currentNumber >= nbMXBean) {
            return true;
        }
        else {
            return false;
        }
    }",1
VvrTaskOperation.java,/** * Operation of a VVR task. * * @author oodrive * @author ebredzinski * */,"public enum VvrTaskOperation {
    CREATE, DELETE, SET, CLONE;
}",1
WaitForInstanceToReachStateTask.java,/** * Set the ID of the instance to wait for. * * @param instanceId *            The ID of the instance to wait for. */,"public void setInstanceId(String instanceId) {
        this.instanceId = instanceId;
    }",1
WaitForNatTablePopupMenu.java,/** * Get popupMenuAction from ui Binding Registry of NatTable by creating * MouseDown event. The private variable menu is obtained by using Java * reflection. * * @return Menu of NatTable for the given cell */,"private Menu getNatTableMenu() {
		Event event = NatTableContextMenuFinder.createMouseEvent(control, x, y, 3, SWT.NONE, 1);
		MouseEvent mouseevent = new MouseEvent(event);
		IMouseAction action = ((NatTable) control).getUiBindingRegistry().getMouseDownAction(mouseevent);
		if (action instanceof PopupMenuAction) {
			PopupMenuAction popupMenuAction = (PopupMenuAction) action;
			Field privateMenu = null;
			try {
				privateMenu = PopupMenuAction.class.getDeclaredField(""menu"");
			} catch (NoSuchFieldException e) {
				return null;
			} catch (SecurityException e) {
				return null;
			}
			privateMenu.setAccessible(true);
			try {
				return (Menu) privateMenu.get(popupMenuAction);
			} catch (IllegalArgumentException e) {
				return null;
			} catch (IllegalAccessException e) {
				return null;
			}
		}
		return null;
	}",1
WaitForShell.java,/** * Condiion that waits for a shell with the specified text to appear. * * @see Conditions * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt; * @version $Id$ * @since 2.0 */,"class WaitForShell extends WaitForObjectCondition<Shell> {

	WaitForShell(Matcher<Shell> matcher) {
		super(matcher);
	}

	public String getFailureMessage() {
		return ""Could not find shell matching: "" + matcher; //$NON-NLS-1$
	}

	protected List<Shell> findMatches() {
		Shell[] shells = findShells();
		ArrayList<Shell> matchingShells = new ArrayList<Shell>();
		for (Shell shell : shells) {
			if (matcher.matches(shell)) {
				matchingShells.add(shell);
			}
		}
		return matchingShells;
	}

	/**
	 * Subclasses may override to find other shells.
	 */
	Shell[] findShells() {
		return bot.getFinder().getShells();
	}

}",1
WaitForStackToReachStateTask.java,"/** * Waits for the specified stack to reach the specified status. Returns true * if it does, returns false if it reaches a status with ""FAILED"", or if 30 * minutes pass without reaching the desired status. */","private void checkParams() {
        boolean areMissingParams = false;
        StringBuilder errors = new StringBuilder("""");

        if (stackName == null) {
            areMissingParams = true;
            errors.append(""Missing parameter: stackName is required \n"");
        }

        if (status == null) {
            areMissingParams = true;
            errors.append(""Missing parameter: stackName is required \n"");
        }

        if (areMissingParams) {
            throw new BuildException(errors.toString());
        }
    }",1
Wakelock.java,/** * @return the wakeType */,"public int getWakeType() {
		return m_wakeType;
	}",1
Wakelock.java,/** * returns the values of the data */,"public double[] getValues()
	{
		double[] retVal = new double[2];
		retVal[0] = getDuration();
		return retVal;
	}",1
WakeLockUtil.java,"/** * Do a {@link android.content.Context#startService(android.content.Intent) * Context.startService}, but holding a wake lock while the service starts. * This will modify the Intent to hold an extra identifying the wake lock; * when the service receives it in {@link android.app.Service#onStartCommand * Service.onStartCommand}, it should pass back the Intent it receives there to * {@link #completeWakefulIntent(android.content.Intent)} in order to release * the wake lock. * * @param context The Context in which it operate. * @param intent The Intent with which to start the service, as per * {@link android.content.Context#startService(android.content.Intent) * Context.startService}. */","public static ComponentName startWakefulService(Context context, Intent intent) {
        synchronized (ACTIVE_WAKE_LOCKS) {
            int id = nextId;
            nextId++;
            if (nextId <= 0) {
                nextId = 1;
            }

            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);
            ComponentName comp = context.startService(intent);
            if (comp == null) {
                return null;
            }

            String tag = ""wake:"" + comp.flattenToShortString();
            PowerManager.WakeLock wakeLock = acquireWakeLock(context, tag, TimeUnit.MINUTES.toMillis(3));
            if (wakeLock != null) {
                ACTIVE_WAKE_LOCKS.put(id, wakeLock);
            }

            return comp;
        }
    }",1
WalkFSABoolean.java,/** * Collect annotations starting at the state * @param state start state * @param needSep true if needed a separator to output list * @param sepValue separator value * * @return annotation data */,"public TIntArrayList collectAnnotationsSimple(int state, boolean needSep, int sepValue) {
        TIntArrayList annots = new TIntArrayList();

        if(!hasAnnotStart(state))
            return annots;

        AnnotationCollector proc = new AnnotationCollector(annots, needSep, sepValue);

        TIntArrayList data = new TIntArrayList();
        collectAnnotations(next(state, 0), data, true, proc);
        return annots;
    }",1
WalkFSABoolean.java,"/** * Collect annotations starting at this (or at any descendent) state * @param state start state * @param annots output list for annotations * @param addSep if true, add specified separator to the output list * @param sepValue separator value for output list * * @return annotation data */","public TIntArrayList collectAnnotations(int state, TIntArrayList annots, boolean addSep, int sepValue) {
        AnnotationCollector proc = new AnnotationCollector(annots, addSep, sepValue);

        collectAnnotations(state, new TIntArrayList(), false, proc);
        return annots;
    }",1
WalkFSABoolean.java,/** * Recursively collect annotation from the FSA * @param state start state * @param data current annotation data * @param passedAnnotChar flag of passing the annotation char in the FSA * @param proc annotation processor * * @return annotation data */,"public void collectAnnotations(int state, TIntArrayList data, boolean passedAnnotChar, AnnotationProcessor proc) {

        if(finals.get(state)) {
            boolean res = proc.process(data);
            if(res)
                return;
        }

        int start = stateStart.get(state);
        int end = state < stateStart.size() - 1? stateStart.get(state + 1) : stateStart.size();

        while(start < end) {
            int input = labels.get(start);
            if(passedAnnotChar)
                data.add(labels.get(start));

            collectAnnotations(dest.get(start), data, input == 0? true : passedAnnotChar, proc);

            if(passedAnnotChar)
                data.removeAt((data.size() - 1));
            start++;
        }

    }",1
WalkieService.java,/* Channel has 2 possible operations to stop: *    - service registration *    - service resolve */,"final CountDownLatch stopLatch = new CountDownLatch( 2 );
        m_channel.stop( stopLatch );

        try
        {
            stopLatch.await();
        }",1
WalkingMonster.java,/** * @param difficulty * @return */,"@Override
    public int getMinDamage(Integer difficulty) {
        if (difficulty == null || difficulty > 3 || difficulty < 0) {
            difficulty = Server.getInstance().getDifficulty();
        }
        return this.minDamage[difficulty];
    }",1
WalkingMonster.java,/** * @param damage */,"@Override
    public void setDamage(int damage) {
        this.setDamage(damage, Server.getInstance().getDifficulty());
    }",1
WalkingMonster.java,/** * @param damage * @param difficulty */,"@Override
    public void setMinDamage(int damage, int difficulty) {
        if (difficulty >= 1 && difficulty <= 3) {
            this.minDamage[difficulty] = Math.min(damage, this.getMaxDamage(difficulty));
        }
    }",1
WalledMazeRandomizer.java,/** * Evaluates if the Cell is Out of Bounds * * @param allCells * @param currentX * @param currentZ * @return */,"private boolean isCellOutOfBounds(MazeCell[][] allCells, int currentX, int currentZ) {
        return currentX < 0 || currentX >= allCells.length || currentZ < 0 || currentZ >= allCells[0].length;
    }",1
WalletPrecheckoutDataRequest.java,/** * Sets the value of the pairingDataType property. * * @param value *     allowed object is *     {@link WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType } * */,"public void setPairingDataType(WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType value) {
            this.pairingDataType = value;
        }",1
WallImageActivity.java,/** * Loads the {@link red.yelo.fragments.ImageViewFragment} into the fragment container * and opens the image through the url supplied */,"public void loadWallImageScreen(String wall_image) {


        Bundle args = new Bundle();
        args.putString(AppConstants.Keys.WALL_IMAGES, wall_image);
        loadFragment(R.id.frame_content, (AbstractYeloFragment) Fragment
                        .instantiate(this, ImageViewFragment.class
                                .getName(), args), AppConstants.FragmentTags.SEARCH, false,
                null
        );

    }",1
WallPostFragment.java,/** * loader which starts loading the wall comments for the wall */,"private void loadWallComments() {
        getLoaderManager().restartLoader(AppConstants.Loaders.LOAD_WALL_COMMENTS, null, this);

    }",1
WallPostFragment.java,/** * Open a post for editing * * @param selectedWallId The id of the post to edit */,"private void editPost(final String selectedWallId) {

        final Intent editWallPostIntent = new Intent(getActivity(), EditWallPostActivity.class);
        editWallPostIntent.putExtra(AppConstants.Keys.EDIT_POST, true);
        editWallPostIntent.putExtra(AppConstants.Keys.WALL_ID, selectedWallId);

        startActivity(editWallPostIntent);
    }",1
WallPostFragment.java,"/** * Delete a post, along with a confirmation * * @param selectedWallId The id of the post to delete */","private void deletePost(final String selectedWallId) {

        final AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(getActivity());

        // set title
        alertDialogBuilder.setTitle(""Confirm"");

        // set dialog message
        alertDialogBuilder.setMessage(getResources().getString(R.string.delete_wall_alert_message)).setCancelable(false).setPositiveButton(""Yes"", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(final DialogInterface dialog, final int id) {

                callDeleteApi(selectedWallId);
                dialog.dismiss();
            }
        }).setNegativeButton(""No"", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(final DialogInterface dialog, final int id) {
                // if this button is clicked, just close
                // the dialog box and do nothing
                dialog.cancel();
            }
        });

        // create alert dialog
        final AlertDialog alertDialog = alertDialogBuilder.create();

        // show it
        alertDialog.show();
    }",1
WallsViewActivity.java,/** * Loads the {@link red.yelo.fragments.WallPostFragment} into the fragment container */,"public void loadWalls(Bundle args) {


        loadFragment(R.id.frame_content, (AbstractYeloFragment) Fragment
                        .instantiate(this, YeloBoardFragment.class
                                .getName(), args), AppConstants.FragmentTags.WALLS, false,
                null
        );

    }",1
WampConnection.java,/** * Create new random ID of default length. * * @return    New random ID of default length. */,"private String newId() {
      return newId(8);
   }",1
WampConnection.java,/** * Subscribe to topic to receive events for. * * @param topicUri         URI or CURIE of topic to subscribe to. * @param meta             Subscription metadata. */,"private void subscribe(String topicUri, SubMeta meta) {

      String uri = mOutgoingPrefixes.resolveOrPass(topicUri);

      if (!mSubs.containsKey(uri)) {

         mSubs.put(uri, meta);

         WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
         mWriter.forward(msg);
      }
   }",1
WampConnection.java,/** * Unsubscribe from any subscribed topic. */,"public void unsubscribe() {

      for (String topicUri : mSubs.keySet()) {

         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
         mWriter.forward(msg);
      }
      mSubs.clear();
   }",1
WampConnection.java,/** * Establish a prefix to be used in CURIEs. * * @param prefix     The prefix to be used in CURIEs. * @param uri        The full URI this prefix shall resolve to. */,"public void prefix(String prefix, String uri) {

      String currUri = mOutgoingPrefixes.get(prefix);

      if (currUri == null || !currUri.equals(uri)) {

         mOutgoingPrefixes.set(prefix, uri);

         WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
         mWriter.forward(msg);
      }
   }",1
WarnChecksumPolicy.java,/** * Implements {@link org.eclipse.aether.repository.RepositoryPolicy#CHECKSUM_POLICY_WARN}. */,"final class WarnChecksumPolicy
    extends AbstractChecksumPolicy
{

    public WarnChecksumPolicy( LoggerFactory loggerFactory, TransferResource resource )
    {
        super( loggerFactory, resource );
    }

    public boolean onTransferChecksumFailure( ChecksumFailureException exception )
    {
        String msg =
            ""Could not validate integrity of download from "" + resource.getRepositoryUrl() + resource.getResourceName();
        if ( logger.isDebugEnabled() )
        {
            logger.warn( msg, exception );
        }
        else
        {
            logger.warn( msg + "": "" + exception.getMessage() );
        }
        return true;
    }

}",1
WarriorRepository.java,/** * Reads all warrior data files from the warriors' directory. * * @throws IOException */,"private void readWarriorFiles() throws IOException {
        readWarriorsFileFromPath(WARRIOR_DIRECTORY);
        readZombiesFiles();
    }",1
WAStorageClientUploadIT.java,"/** * Test of validateStorageAccount method, of class WAStorageClient. */","@Test(expected = WAStorageException.class)
    public void testInvalidateStorageAccount1() throws Exception {
        System.out.println(""Testing Invalid StorageAccount"");
        AzureUtils.validateStorageAccount(new StorageAccountInfo(testEnv.azureStorageAccountName, ""asdhasdh@asdas!@234="", testEnv.blobURL));
        testEnv.container.deleteIfExists();
    }",1
WAStorageClientUploadIT.java,"/** * Test of validateStorageAccount method, of class WAStorageClient. */","@Test(expected = WAStorageException.class)
    public void testInvalidateStorageAccount2() throws Exception {
        System.out.println(""Testing Invalid StorageAccount"");
        AzureUtils.validateStorageAccount(new StorageAccountInfo(""rfguthio123"", testEnv.azureStorageAccountKey2, testEnv.blobURL));
        testEnv.container.deleteIfExists();
    }",1
WAStoragePublisher.java,/** * Allowing anonymous access for links generated by jenkins. */,"public boolean isAllowAnonymousAccess() {
        return allowAnonymousAccess;
    }",1
WatchDataSourceImplTest.java,/* * Asserts that a given object is a actually a proxy to a given * implementation object. */,"private void assertValidProxy(WatchDataSource proxy,
                                  LoggingWatchDataSourceImpl impl)
            throws RemoteException {
        impl.log().delete(0, impl.log().length());
        proxy.clear();
        proxy.getCalculable();
        proxy.getCurrentSize();
        proxy.getID();
        proxy.getLastCalculable();
        proxy.getMaxSize();
        proxy.getThresholdValues();
        proxy.getView();
        //proxy.setMaxSize(1);
        proxy.setView(""aaa"");
        checkLog(impl.log, ""clear()""
                           + ""getCalculable()""
                           //+ ""getCalculable(0,1)""
                           //+ ""getCalculable(watch,0,1)""
                           + ""getCurrentSize()""
                           + ""getID()""
                           + ""getLastCalculable()""
                           + ""getMaxSize()""
                           + ""getThresholdValues()""
                           + ""getView()""
                           //+ ""setMaxSize(1)""
                           + ""setView(aaa)"");
    }",1
WatchDataSourceImplTest.java,"/* * Checks that a given string buffer (used as a log) holds a given * string, and clears the string buffer. */","private void checkLog(StringBuffer log, String s) {
        Assert.assertEquals(s, log.toString());
        log.delete(0, log.length());
    }",1
WatchDataSourceImplTest.java,/* * Asserts that all objects in a given collection are same. */,"private void assertAllSame(Collection collection) {
        if (collection.isEmpty()) {
            return;
        }
        Iterator i = collection.iterator();
        Object obj = i.next();
        while (i.hasNext()) {
            Assert.assertSame(obj, i.next());
        }
    }",1
WatchDataSourceImplTest.java,"/* * Asserts that the <code>addCalculable</code> method really works for * the current state of a given data source, that is, calculables get * into the history. The method verifies this by calling * <code>addCalculable</code> the specified number of times and * checking the history. * * @param ds    the data source to verify * @param count the required number of calls to <code>addCalculable</code> * @param works specifies whether <code>addCalculable</code> should *              work or not */","private void assertAddCalculableWorks(WatchDataSource ds,
                                          int count,
                                          boolean works) throws RemoteException {
        ds.clear();
        List<Calculable> expected = new ArrayList<Calculable>();
        Calculable expectedLast = null;
        for (int j = 0; j < count; j++) {
            Calculable c = new Calculable();
            ds.addCalculable(c);
            if (works) {
                expected.add(c);
                expectedLast = c;
            }
        }

        DataSourceMonitor detector = new DataSourceMonitor(ds);
        detector.waitFor(works ? count : 0);

        List calculables = Arrays.asList(ds.getCalculable());
        Utils.assertSameContents(expected, calculables);
        Assert.assertEquals(expected.size(), ds.getCurrentSize());
        Assert.assertSame(expectedLast, ds.getLastCalculable());
        ds.clear();
    }",1
Waterfall.java,/** * Execute the waterfall. * * @param callback          Callback for the task * @return */,"public Future execute (CompletionCallback <Object> callback)
  {
    return this.execute (null, callback);
  }",1
WatsAgentStatusResponse.java,/** * @return SkipGroups */,"public int getSkipGroups() {
        return skipGroups;
    }",1
WatsAgentStatusResponse.java,/** * @return Restarts */,"public int getRestarts() {
        return restarts;
    }",1
WaveDrawable.java,/** * Set customised animator for wave loading animation * @param animator */,"public void setIndeterminateAnimator(ValueAnimator animator) {
        if (mAnimator == animator) {
            return;
        }

        if (mAnimator != null) {
            mAnimator.removeUpdateListener(this);
            mAnimator.cancel();
        }

        mAnimator = animator;
        if (mAnimator != null) {
            mAnimator.addUpdateListener(this);
        }
    }",1
WaveformAnalysis.java,/** * This function sums up over a series of intensity/time values. * @param list A list of intensity/time points. * @return A point of summed intensities with the time set to the start of the list. */,"private static XZ sumIntensityAndTimeList(List<XZ> list) {
    // We use the first value's time as a period over which the intensities are summed over. This is a conscious
    // choice to standardize the summation analysis. The trade offs are that the final output will
    // not have an accurate time period and will always underestimate the actual time, but since
    // the time period over which it is the summed is small (< 1 second), the underestimation is within comfortable
    // bounds.
    Double time = list.get(START_INDEX).getTime();
    Double intensitySum = 0.0;
    for (XZ point : list) {
      intensitySum += point.getIntensity();
    }

    return new XZ(time, intensitySum);
  }",1
WaveformAnalysis.java,/** * This function returns the maximum noise among a map of ion to list of spectra * @param spectra A map of ion to spectrum * @return The maximum noise of the map */,"public static Double maxNoiseOfSpectra(Map<String, List<XZ>> spectra) {
    Double maxNoise = Double.MIN_VALUE;
    for (Map.Entry<String, List<XZ>> ionToSpectrum : spectra.entrySet()) {
      maxNoise = Math.max(maxNoise, noiseOfSpectrum(ionToSpectrum.getValue()));
    }
    return maxNoise;
  }",1
WavefrontStrings.java,/** * Convert a name to a name that wavefront will accept. * * Wavefront documentation specifies a metric consists of the characters * [-a-zA-Z_0-9.] Any disallowed characters are replaced with underscores. */,"public static final String name(String name) {
        return name
                .toLowerCase(Locale.ROOT)
                .replaceAll(""[^-a-zA-Z_0-9.]"", ""_"");
    }",1
WavefrontStrings.java,/** * Convert a timestamp to the string representation that wavefront will * accept. */,"public static String timestamp(DateTime ts) {
        return Long.toString(ts.getMillis() / 1000);
    }",1
WaveReader.java,/** * Constructor; initializes WaveReader to read from given file * * @param path  path to input file * @param name  name of input file */,"public WaveReader(String path, String name) {
        this.mInFile = new File(path + File.separator + name);
    }",1
WaveReader.java,/** * Get input file's audio data size * Basically file size without headers included * * @return audio data size in bytes */,"public int getDataSize() {
        return mDataSize;
    }",1
WaveReader.java,/** * Get input file length * * @return length of file in seconds */,"public int getLength() {
        if (mSampleRate == 0 || mChannels == 0 || (mSampleBits + 7) / 8 == 0) {
            return 0;
        } else {
            return mDataSize / (mSampleRate * mChannels * ((mSampleBits + 7) / 8));
        }
    }",1
WaveWriter.java,/** * Create output WAV file * * @return whether file creation succeeded * * @throws IOException if file I/O error occurs allocating header */,"public boolean createWaveFile() throws IOException {
        if (mOutFile.exists()) {
            mOutFile.delete();
        }

        if (mOutFile.createNewFile()) {
            FileOutputStream fileStream = new FileOutputStream(mOutFile);
            mOutStream = new BufferedOutputStream(fileStream, OUTPUT_STREAM_BUFFER);
            // write 44 bytes of space for the header
            mOutStream.write(new byte[44]);
            return true;
        }
        return false;
    }",1
WaveWriter.java,/** * Write audio data to output file (stereo). Does * nothing if output file is not stereo channel. * * @param left  left channel audio data buffer * @param right  right channel audio data buffer * @param offset  offset into left/right buffers * @param length  buffer size in number of samples * * @throws IOException if file I/O error occurs */,"public void write(short[] left, short[] right, int offset, int length) throws IOException {
        if (mChannels != 2) {
            return;
        }
        if (offset > length) {
            throw new IndexOutOfBoundsException(String.format(""offset %d is greater than length %d"", offset, length));
        }
        for (int i = offset; i < length; i++) {
            writeUnsignedShortLE(mOutStream, left[i]);
            writeUnsignedShortLE(mOutStream, right[i]);
            mBytesWritten += 4;
        }
    }",1
WBSCategoryType.java,/** * Gets the value of the createDate property. * * @return *     possible object is *     {@link String } * */,"public Date getCreateDate()
   {
      return createDate;
   }",1
WBSCategoryType.java,/** * Sets the value of the createDate property. * * @param value *     allowed object is *     {@link String } * */,"public void setCreateDate(Date value)
   {
      this.createDate = value;
   }",1
WBSCategoryType.java,/** * Gets the value of the createUser property. * * @return *     possible object is *     {@link String } * */,"public String getCreateUser()
   {
      return createUser;
   }",1
WBSCategoryType.java,/** * Sets the value of the createUser property. * * @param value *     allowed object is *     {@link String } * */,"public void setCreateUser(String value)
   {
      this.createUser = value;
   }",1
WBSCategoryType.java,/** * Gets the value of the lastUpdateDate property. * * @return *     possible object is *     {@link String } * */,"public Date getLastUpdateDate()
   {
      return lastUpdateDate;
   }",1
WBSCategoryType.java,/** * Sets the value of the lastUpdateUser property. * * @param value *     allowed object is *     {@link String } * */,"public void setLastUpdateUser(String value)
   {
      this.lastUpdateUser = value;
   }",1
WBSCategoryType.java,/** * Gets the value of the name property. * * @return *     possible object is *     {@link String } * */,"public String getName()
   {
      return name;
   }",1
WBSMilestoneType.java,/** * Gets the value of the createUser property. * * @return *     possible object is *     {@link String } * */,"public String getCreateUser()
   {
      return createUser;
   }",1
WBSMilestoneType.java,/** * Sets the value of the isTemplate property. * * @param value *     allowed object is *     {@link Boolean } * */,"public void setIsTemplate(Boolean value)
   {
      this.isTemplate = value;
   }",1
WBSMilestoneType.java,/** * Sets the value of the lastUpdateDate property. * * @param value *     allowed object is *     {@link String } * */,"public void setLastUpdateDate(Date value)
   {
      this.lastUpdateDate = value;
   }",1
WBSMilestoneType.java,/** * Gets the value of the projectId property. * * @return *     possible object is *     {@link String } * */,"public String getProjectId()
   {
      return projectId;
   }",1
WBSMilestoneType.java,/** * Sets the value of the projectId property. * * @param value *     allowed object is *     {@link String } * */,"public void setProjectId(String value)
   {
      this.projectId = value;
   }",1
WBSMilestoneType.java,/** * Sets the value of the sequenceNumber property. * * @param value *     allowed object is *     {@link Integer } * */,"public void setSequenceNumber(Integer value)
   {
      this.sequenceNumber = value;
   }",1
WBSType.java,/** * Gets the value of the anticipatedFinishDate property. * * @return *     possible object is *     {@link String } * */,"public Date getAnticipatedFinishDate()
   {
      return anticipatedFinishDate;
   }",1
WBSType.java,/** * Sets the value of the anticipatedStartDate property. * * @param value *     allowed object is *     {@link String } * */,"public void setAnticipatedStartDate(Date value)
   {
      this.anticipatedStartDate = value;
   }",1
WBSType.java,/** * Gets the value of the createUser property. * * @return *     possible object is *     {@link String } * */,"public String getCreateUser()
   {
      return createUser;
   }",1
WBSType.java,/** * Gets the value of the currentVariance property. * * @return *     possible object is *     {@link Double } * */,"public Double getCurrentVariance()
   {
      return currentVariance;
   }",1
WBSType.java,/** * Sets the value of the earnedValueComputeType property. * * @param value *     allowed object is *     {@link String } * */,"public void setEarnedValueComputeType(String value)
   {
      this.earnedValueComputeType = value;
   }",1
WBSType.java,/** * Gets the value of the isBaseline property. * * @return *     possible object is *     {@link Boolean } * */,"public Boolean isIsBaseline()
   {
      return isBaseline;
   }",1
WBSType.java,/** * Gets the value of the lastUpdateUser property. * * @return *     possible object is *     {@link String } * */,"public String getLastUpdateUser()
   {
      return lastUpdateUser;
   }",1
WBSType.java,/** * Gets the value of the originalBudget property. * * @return *     possible object is *     {@link Double } * */,"public Double getOriginalBudget()
   {
      return originalBudget;
   }",1
WBSType.java,/** * Gets the value of the parentObjectId property. * * @return *     possible object is *     {@link Integer } * */,"public Integer getParentObjectId()
   {
      return parentObjectId;
   }",1
WBSType.java,/** * Sets the value of the parentObjectId property. * * @param value *     allowed object is *     {@link Integer } * */,"public void setParentObjectId(Integer value)
   {
      this.parentObjectId = value;
   }",1
WBSType.java,/** * Sets the value of the projectId property. * * @param value *     allowed object is *     {@link String } * */,"public void setProjectId(String value)
   {
      this.projectId = value;
   }",1
WBSType.java,/** * Gets the value of the statusReviewerObjectId property. * * @return *     possible object is *     {@link Integer } * */,"public Integer getStatusReviewerObjectId()
   {
      return statusReviewerObjectId;
   }",1
WBSType.java,/** * Gets the value of the summaryAccountingVarianceByLaborUnits property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryAccountingVarianceByLaborUnits()
   {
      return summaryAccountingVarianceByLaborUnits;
   }",1
WBSType.java,/** * Sets the value of the summaryAccountingVarianceByLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryAccountingVarianceByLaborUnits(Double value)
   {
      this.summaryAccountingVarianceByLaborUnits = value;
   }",1
WBSType.java,/** * Gets the value of the summaryActivityCount property. * * @return *     possible object is *     {@link Integer } * */,"public Integer getSummaryActivityCount()
   {
      return summaryActivityCount;
   }",1
WBSType.java,/** * Sets the value of the summaryActivityCount property. * * @param value *     allowed object is *     {@link Integer } * */,"public void setSummaryActivityCount(Integer value)
   {
      this.summaryActivityCount = value;
   }",1
WBSType.java,/** * Gets the value of the summaryActualFinishDate property. * * @return *     possible object is *     {@link String } * */,"public Date getSummaryActualFinishDate()
   {
      return summaryActualFinishDate;
   }",1
WBSType.java,/** * Gets the value of the summaryActualLaborUnits property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryActualLaborUnits()
   {
      return summaryActualLaborUnits;
   }",1
WBSType.java,/** * Sets the value of the summaryActualNonLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryActualNonLaborUnits(Double value)
   {
      this.summaryActualNonLaborUnits = value;
   }",1
WBSType.java,/** * Sets the value of the summaryActualThisPeriodNonLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryActualThisPeriodNonLaborUnits(Double value)
   {
      this.summaryActualThisPeriodNonLaborUnits = value;
   }",1
WBSType.java,/** * Sets the value of the summaryActualTotalCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryActualTotalCost(Double value)
   {
      this.summaryActualTotalCost = value;
   }",1
WBSType.java,/** * Gets the value of the summaryActualValueByCost property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryActualValueByCost()
   {
      return summaryActualValueByCost;
   }",1
WBSType.java,/** * Sets the value of the summaryActualValueByCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryActualValueByCost(Double value)
   {
      this.summaryActualValueByCost = value;
   }",1
WBSType.java,/** * Gets the value of the summaryActualValueByLaborUnits property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryActualValueByLaborUnits()
   {
      return summaryActualValueByLaborUnits;
   }",1
WBSType.java,/** * Sets the value of the summaryAtCompletionDuration property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryAtCompletionDuration(Double value)
   {
      this.summaryAtCompletionDuration = value;
   }",1
WBSType.java,/** * Sets the value of the summaryAtCompletionLaborCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryAtCompletionLaborCost(Double value)
   {
      this.summaryAtCompletionLaborCost = value;
   }",1
WBSType.java,/** * Sets the value of the summaryAtCompletionNonLaborCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryAtCompletionNonLaborCost(Double value)
   {
      this.summaryAtCompletionNonLaborCost = value;
   }",1
WBSType.java,/** * Sets the value of the summaryBaselineExpenseCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryBaselineExpenseCost(Double value)
   {
      this.summaryBaselineExpenseCost = value;
   }",1
WBSType.java,/** * Sets the value of the summaryBaselineFinishDate property. * * @param value *     allowed object is *     {@link String } * */,"public void setSummaryBaselineFinishDate(Date value)
   {
      this.summaryBaselineFinishDate = value;
   }",1
WBSType.java,/** * Sets the value of the summaryBaselineLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryBaselineLaborUnits(Double value)
   {
      this.summaryBaselineLaborUnits = value;
   }",1
WBSType.java,/** * Gets the value of the summaryBaselineMaterialCost property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryBaselineMaterialCost()
   {
      return summaryBaselineMaterialCost;
   }",1
WBSType.java,/** * Sets the value of the summaryBaselineNonLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryBaselineNonLaborUnits(Double value)
   {
      this.summaryBaselineNonLaborUnits = value;
   }",1
WBSType.java,/** * Gets the value of the summaryCostPercentComplete property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryCostPercentComplete()
   {
      return summaryCostPercentComplete;
   }",1
WBSType.java,/** * Sets the value of the summaryCostVarianceByCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryCostVarianceByCost(Double value)
   {
      this.summaryCostVarianceByCost = value;
   }",1
WBSType.java,/** * Sets the value of the summaryCostVarianceByLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryCostVarianceByLaborUnits(Double value)
   {
      this.summaryCostVarianceByLaborUnits = value;
   }",1
WBSType.java,/** * Sets the value of the summaryDurationPercentOfPlanned property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryDurationPercentOfPlanned(Double value)
   {
      this.summaryDurationPercentOfPlanned = value;
   }",1
WBSType.java,/** * Sets the value of the summaryDurationVariance property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryDurationVariance(Double value)
   {
      this.summaryDurationVariance = value;
   }",1
WBSType.java,/** * Gets the value of the summaryEarnedValueByCost property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryEarnedValueByCost()
   {
      return summaryEarnedValueByCost;
   }",1
WBSType.java,/** * Sets the value of the summaryEstimateAtCompletionByLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryEstimateAtCompletionByLaborUnits(Double value)
   {
      this.summaryEstimateAtCompletionByLaborUnits = value;
   }",1
WBSType.java,/** * Sets the value of the summaryExpenseCostVariance property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryExpenseCostVariance(Double value)
   {
      this.summaryExpenseCostVariance = value;
   }",1
WBSType.java,/** * Sets the value of the summaryFinishDateVariance property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryFinishDateVariance(Double value)
   {
      this.summaryFinishDateVariance = value;
   }",1
WBSType.java,/** * Gets the value of the summaryInProgressActivityCount property. * * @return *     possible object is *     {@link Integer } * */,"public Integer getSummaryInProgressActivityCount()
   {
      return summaryInProgressActivityCount;
   }",1
WBSType.java,/** * Gets the value of the summaryLaborCostPercentComplete property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryLaborCostPercentComplete()
   {
      return summaryLaborCostPercentComplete;
   }",1
WBSType.java,/** * Sets the value of the summaryLaborCostPercentComplete property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryLaborCostPercentComplete(Double value)
   {
      this.summaryLaborCostPercentComplete = value;
   }",1
WBSType.java,/** * Sets the value of the summaryNonLaborCostVariance property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryNonLaborCostVariance(Double value)
   {
      this.summaryNonLaborCostVariance = value;
   }",1
WBSType.java,/** * Gets the value of the summaryNonLaborUnitsVariance property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryNonLaborUnitsVariance()
   {
      return summaryNonLaborUnitsVariance;
   }",1
WBSType.java,/** * Sets the value of the summaryPerformancePercentCompleteByLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryPerformancePercentCompleteByLaborUnits(Double value)
   {
      this.summaryPerformancePercentCompleteByLaborUnits = value;
   }",1
WBSType.java,/** * Sets the value of the summaryPlannedLaborCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryPlannedLaborCost(Double value)
   {
      this.summaryPlannedLaborCost = value;
   }",1
WBSType.java,/** * Gets the value of the summaryPlannedMaterialCost property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryPlannedMaterialCost()
   {
      return summaryPlannedMaterialCost;
   }",1
WBSType.java,/** * Sets the value of the summaryPlannedNonLaborCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryPlannedNonLaborCost(Double value)
   {
      this.summaryPlannedNonLaborCost = value;
   }",1
WBSType.java,/** * Sets the value of the summaryPlannedValueByCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryPlannedValueByCost(Double value)
   {
      this.summaryPlannedValueByCost = value;
   }",1
WBSType.java,/** * Gets the value of the summaryRemainingDuration property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryRemainingDuration()
   {
      return summaryRemainingDuration;
   }",1
WBSType.java,/** * Gets the value of the summaryRemainingFinishDate property. * * @return *     possible object is *     {@link String } * */,"public Date getSummaryRemainingFinishDate()
   {
      return summaryRemainingFinishDate;
   }",1
WBSType.java,/** * Gets the value of the summaryRemainingLaborUnits property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryRemainingLaborUnits()
   {
      return summaryRemainingLaborUnits;
   }",1
WBSType.java,/** * Sets the value of the summaryRemainingNonLaborCost property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryRemainingNonLaborCost(Double value)
   {
      this.summaryRemainingNonLaborCost = value;
   }",1
WBSType.java,/** * Gets the value of the summaryScheduleVarianceByLaborUnits property. * * @return *     possible object is *     {@link Double } * */,"public Double getSummaryScheduleVarianceByLaborUnits()
   {
      return summaryScheduleVarianceByLaborUnits;
   }",1
WBSType.java,/** * Sets the value of the summaryVarianceAtCompletionByLaborUnits property. * * @param value *     allowed object is *     {@link Double } * */,"public void setSummaryVarianceAtCompletionByLaborUnits(Double value)
   {
      this.summaryVarianceAtCompletionByLaborUnits = value;
   }",1
WBSType.java,/** * Gets the value of the totalBenefitPlan property. * * @return *     possible object is *     {@link Double } * */,"public Double getTotalBenefitPlan()
   {
      return totalBenefitPlan;
   }",1
WBSType.java,/** * Gets the value of the totalSpendingPlan property. * * @return *     possible object is *     {@link Double } * */,"public Double getTotalSpendingPlan()
   {
      return totalSpendingPlan;
   }",1
WBSType.java,/** * Sets the value of the totalSpendingPlan property. * * @param value *     allowed object is *     {@link Double } * */,"public void setTotalSpendingPlan(Double value)
   {
      this.totalSpendingPlan = value;
   }",1
WBSType.java,/** * Sets the value of the wbsMilestonePercentComplete property. * * @param value *     allowed object is *     {@link Double } * */,"public void setWBSMilestonePercentComplete(Double value)
   {
      this.wbsMilestonePercentComplete = value;
   }",1
WBSType.java,"/** * Gets the value of the udf property. * * <p> * This accessor method returns a reference to the live list, * not a snapshot. Therefore any modification you make to the * returned list will be present inside the JAXB object. * This is why there is not a <CODE>set</CODE> method for the udf property. * * <p> * For example, to add a new item, do as follows: * <pre> *    getUDF().add(newItem); * </pre> * * * <p> * Objects of the following type(s) are allowed in the list * {@link UDFAssignmentType } * * */","public List<UDFAssignmentType> getUDF()
   {
      if (udf == null)
      {
         udf = new ArrayList<UDFAssignmentType>();
      }
      return this.udf;
   }",1
WcmCommandHandler.java,/** * Activates provided asset * * @param assetPath path to asset * @throws IOException if response doesn't contain desired message */,"public void activatePage(String assetPath) throws IOException {
    triggerAction(Maps.newHashMap(new ImmutableMap.Builder<String, String>()
        .put(PATH_PROPERTY, assetPath)
        .put(CMD_PROPERTY, ACTIVATE)
        .put(CHARSET_PROPERTY, UTF_8).build()), REPLICATE_URL,
        REPLICATION_STARTED_MESSAGE + assetPath);
  }",1
WeakRemoteEventListener.java,/** * Used in order to weakly hold listeners by the Notify delegator. * * @author Guy Korland * @version 1.0 * @since 5.01 */,"@com.gigaspaces.api.InternalApi
public class WeakRemoteEventListener extends WeakReference<RemoteEventListener>
        implements RemoteEventListener {
    public WeakRemoteEventListener(RemoteEventListener listener) {
        super(listener);
    }

    /**
     * Delegate the notification to the listener.
     */
    public void notify(RemoteEvent event) throws UnknownEventException, RemoteException {
        RemoteEventListener l = get();
        if (l != null) {
            l.notify(event);
        }
    }
}",1
WeakWorldReference.java,/** * Gets the unique id of the world of this reference. * * @return the unique id */,"public UUID getUniqueId() {
        return this.uniqueId;
    }",1
WeaponTest.java,/** * Make sure {@link Weapon#getDamagePerShot()} returns the volley damage and not projectile damage. */,"@Test
    public void testGetDamagePerShot_lb10x() throws Exception {
        final Weapon lb10xac = (Weapon) ItemDB.lookup(""LB 10-X AC"");
        assertTrue(lb10xac.getDamagePerShot() > 5);
    }",1
WeaponTest.java,"/** * When taking the quotient of two stats that are zero we're faced with interpreting 0/0. Although not strictly * mathematically correct, we will interpret x/y as 'x' per 'y' and if 'x' is zero we will output zero if 'y' is * also finite.a */","@Test
    public void testGetStatZeroOverZero() {
        // AMS has no heat.
        assertEquals(0.0, ItemDB.AMS.getHeat(null), 0.0);
        assertEquals(0.0, ItemDB.AMS.getStat(""h/h"", null), 0.0);
    }",1
weapontype_t.java,"/** The defined weapons, * including a marker indicating *  user has not changed weapon. */","public enum weapontype_t
{
    wp_fist,
    wp_pistol,
    wp_shotgun,
    wp_chaingun,
    wp_missile,
    wp_plasma,
    wp_bfg,
    wp_chainsaw,
    wp_supershotgun,

    NUMWEAPONS,
    
    // No pending weapon change.
    wp_nochange;
    
    public String toString(){
        return this.name();
    }
    
}",1
WeatherBuilder.java,/** * Sets the aliases of the {@link LanternWeather}. * * @param aliases The aliases * @return This weather builder */,"public WeatherBuilder aliases(String... aliases) {
        this.aliases = ImmutableSet.copyOf(aliases);
        return this;
    }",1
WeatherBuilder.java,/** * Sets the {@link Action} of the {@link LanternWeather}. * * @param action The action * @return This weather builder */,"public WeatherBuilder action(Action action) {
        this.action = checkNotNull(action, ""action"");
        return this;
    }",1
WeatherNotificationSettings.java,/** * Check if the user only wants to download when on wifi * * @param context * @return true if the user want measurements from the nearest station */,"public static boolean getDownloadOnlyOnWifi(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getBoolean(PREFS_DOWNLOAD_ONLY_ON_WIFI_KEY,
				PREFS_DOWNLOAD_ONLY_ON_WIFI_DEFAULT);

	}",1
WeatherNotificationSettings.java,/** * Gets the date when the last downloaded measurement was measured. * * @param context * @return time for last measurement */,"public static Date getLastUpdateTime(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		final long result = settings.getLong(PREFS_LAST_UPDATE_TIME_KEY, 0l);
		if (result == 0l)
			return null;
		else
			return new Date(result);
	}",1
WeatherNotificationSettings.java,/** * Gets the station id for where the measurement is taken. If the user want * the nearest station this return the last used station. * * @param context * @return station id */,"public static int getStationId(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getInt(PREFS_STATION_ID_KEY, PREFS_STATION_ID_DEFAULT);
	}",1
WeatherNotificationSettings.java,/** * Check if the user want measurements from the nearest station * * @param context * @return true if the user want measurements from the nearest station */,"public static boolean isUsingNearestStation(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getBoolean(PREFS_USE_NEAREST_STATION_KEY,
				PREFS_USE_NEAREST_STATION_DEFAULT);

	}",1
WeatherNotificationSettings.java,"/** * Set the station to be used for updating measurement and delete saved * measurement. If the id is the same as before, nothing is done. NOTE: * {@link WsKlimaProxy#setUseNearestStation(Context, boolean)} must also be * set. * * * @param context * @param name * @param id */","public static void setStation(Context context, String name, int id) {
		final SharedPreferences preferences = context.getSharedPreferences(
				PREFS_NAME, 0);

		// Do nothing if ids are equal
		final int oldId = preferences.getInt(PREFS_STATION_ID_KEY,
				PREFS_STATION_ID_DEFAULT);
		if (oldId == id)
			return;

		final Editor settings = preferences.edit();
		settings.putInt(PREFS_STATION_ID_KEY, id);
		settings.putString(PREFS_STATION_NAME_KEY, name);
		settings.remove(PREFS_LAST_UPDATE_TIME_KEY);
		settings.remove(PREFS_LAST_WEATHER_KEY);
		settings.commit();
	}",1
WeaveCryptoUtil.java,"/** * This code basically inlines usage of the BouncyCastle private API and is equivalent to the following code. * <pre> * {@code * PBEParametersGenerator generator = new PKCS5S2ParametersGenerator(); * generator.init(PBEParametersGenerator.PKCS5PasswordToBytes(secret), salt, 4096); * CipherParameters keyParam = generator.generateDerivedParameters(256); * return ((KeyParameter)keyParam).getKey(); * } * </pre> */","private static byte[] derivePKCS5S2(char[] secret, byte[] salt) throws GeneralSecurityException {
    byte[] secretBytes = passwordPKCS5ToBytes(secret);
    int keySizeInBytes = 256 / 8;
    final int iterations = 4096;
    Mac hMac = Mac.getInstance(""HMACSHA1"");
    int hLen = hMac.getMacLength();
    int l = (keySizeInBytes + hLen - 1) / hLen;
    byte[] iBuf = new byte[4];
    byte[] dKey = new byte[l * hLen];
    for (int i = 1; i <= l; i++) {
      intToOctet(iBuf, i);
      derivePKCS5S2Helper(hMac, secretBytes, salt, iterations, iBuf, dKey, (i - 1) * hLen);
    }
    byte[] retval = new byte[keySizeInBytes];
    System.arraycopy(dKey, 0, retval, 0, keySizeInBytes);
    return retval;
  }",1
WebApplicationMetaData.java,/** * Override to return false to prevent WebApplicationDefaultsProcessor * from setting an empty context to / */,"public boolean forceDefaultContext() {
        return true;
    }",1
WebappManager.java,/** * Writes the data from the List to the file. * * @param file * @param list * @throws IOException */,"private static void writeData(final List<String> list, final File file)
            throws IOException {
        FileWriter fileWriter = new FileWriter(file);
        for (String str : list) {
            fileWriter.write(str + ""\n"");
        }
        fileWriter.flush();
        fileWriter.close();
    }",1
WebAppType.java,"/** * Gets the value of the descriptionAndDisplayNameAndIcon property. * * <p> * This accessor method returns a reference to the live list, * not a snapshot. Therefore any modification you make to the * returned list will be present inside the JAXB object. * This is why there is not a <CODE>set</CODE> method for the descriptionAndDisplayNameAndIcon property. * * <p> * For example, to add a new item, do as follows: * <pre> *    getDescriptionAndDisplayNameAndIcon().add(newItem); * </pre> * * * <p> * Objects of the following type(s) are allowed in the list * {@link DisplayNameType } * {@link FilterType } * {@link ResourceRefType } * {@link ServletMappingType } * {@link ParamValueType } * {@link EmptyType } * {@link JspConfigType } * {@link ServiceRefType } * {@link LocaleEncodingMappingListType } * {@link ResourceEnvRefType } * {@link DescriptionType } * {@link SecurityConstraintType } * {@link MessageDestinationRefType } * {@link ListenerType } * {@link EnvEntryType } * {@link EjbLocalRefType } * {@link MimeMappingType } * {@link LoginConfigType } * {@link IconType } * {@link SessionConfigType } * {@link ServletType } * {@link MessageDestinationType } * {@link FilterMappingType } * {@link ErrorPageType } * {@link EjbRefType } * {@link WelcomeFileListType } * {@link SecurityRoleType } * * */","public List<Object> getDescriptionAndDisplayNameAndIcon() {
        if (descriptionAndDisplayNameAndIcon == null) {
            descriptionAndDisplayNameAndIcon = new ArrayList<Object>();
        }
        return this.descriptionAndDisplayNameAndIcon;
    }",1
WebAppType.java,/** * Gets the value of the id property. * * @return *     possible object is *     {@link java.lang.String } * */,"public java.lang.String getId() {
        return id;
    }",1
WebConnectionBuilder.java,/** * Adds a non encoded HTTP request header * * @param key   - The header key * @param value - The header value */,"public WebConnectionBuilder addHeader(String key, String value) {
        this.headers.put(key, value);
        return this;
    }",1
WebdavServlet.java,/** * Sets the <code>DavSessionProvider</code>. * * @param sessionProvider * @see AbstractWebdavServlet#setDavSessionProvider(org.apache.jackrabbit.webdav.DavSessionProvider) */,"@Override
    public synchronized void setDavSessionProvider(DavSessionProvider sessionProvider) {
        this.davSessionProvider = sessionProvider;
    }",1
WebdavServlet.java,/** * Returns the resource configuration to be applied * * @return the resource configuration. */,"private ResourceConfig getResourceConfig() {
        // fallback if no config present
        if (config == null) {
            config = new ResourceConfig();
        }
        return config;
    }",1
WebdavServlet.java,/** * This is a cheesy way to set the value of the hadoop config * @param config */,"public static void setConf(Configuration config) {
        hadoopConfig = config;   
    }",1
WebDriverElement.java,"/** * Looks up the underlying source {@link org.openqa.selenium.WebElement}. If the element is no * longer present, a {@link org.openqa.selenium.NoSuchElementException} may be thrown. */","@Override
    public WebElement getWrappedElement() {
        return source.lookup();
    }",1
WebDriverElement.java,"/** * Retrieve the ElementContext that this element was found in. Intended to allow element types * to find other elements within the same context, most likely by nesting within themselves. For * example, {@code return By.nested(this, By.htmlTag(""option"")).findAll(SelectOption.class, * getContext());}. */","public ElementContext getContext() {
        return context;
    }",1
WebDriverElement.java,"/** * Expected way for sub element types to interact with their corresponding WebElement. This * attempts the desired action, and will throw appropriate exceptions should the element not be * able to be interacted with, for whatever reason. If the WebElement is stale when the action * is attempted, the cached WebElement will be cleared and looked up again, which may lookup a * fresh reference to the equivalent element. * * @param action A function that wraps the action to be performed. Accepts the source WebElement * as its only parameter and returns the result of this action. * @param <T> Return type of the action. * @return Whatever the action returns. */","protected <T> T attemptAndGet(Function<WebElement, T> action) {
        try {
            return action.apply(webElement());
        } catch (StaleElementReferenceException e) {
            invalidateCache();

            try {
                return action.apply(webElement());
            } catch (ElementNotVisibleException e1) {
                throw new ElementNotDisplayedException(this, e1);
            }
        } catch (ElementNotVisibleException e) {
            throw new ElementNotDisplayedException(this, e);
        }
    }",1
WebDriverUtils.java,/** * Print internal Logger status */,"public static void returnLoggerState() {
		LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
		StatusPrinter.print(lc);
	}",1
WebDriverUtils.java,"/** * Loops to determine if WebDriver.getWindowHandles() returns any *  additional windows that the allHandles cache does not currently *  contain. If new windows are found, switch to latest window and *  update allHandles cache. */","public static String handleNewWindow() {
		String newHandle = """";
		printHandles();
		Set<String> updatedHandles = driver.getWindowHandles();
		if ( updatedHandles.size() <= handleCache.size() ) {
			mainHandle = """";
			throw new IllegalStateException(""This method handleNewWindow is not appropriate\n"" +
					""in this case.  You are probably looking for the\n""+
					""use of the updateHandleCache method."");
		} else {
			if ( !updatedHandles.isEmpty() ) {
				for ( String windowId : updatedHandles ) {
					if ( !windowId.equals( mainHandle ) ) { // for all windows except main window
						if ( !handleCache.contains( windowId) ) { // for child windows not in allHandles cache
							newHandle = windowId; // set value of newly found window handle						
							LOGGER.info(""-- Open window handle: "" + newHandle + "" (new window)"" );
						}
					}
				}
				if ( !newHandle.equals("""") ) { // outside loop so it catches latest window handle if there are multiple
					LOGGER.info(""Switch to new window."");
					driver.switchTo().window( newHandle ); // switch to new window handle
				}
			} else {
				mainHandle = """";
				throw new IllegalStateException(""No browser window handles are open."");
			}
		}
		handleCache = updatedHandles; // updates remembered set of open windows
		return newHandle;
	}",1
WebLogicJMXLibClassLoader.java,"/** * A {@link ClassLoader} that is used to load classes * from <code>WL_HOME/server/lib/weblogic.jar</code>. * <p> * Classloading is delegated to the parent first, before * attempting to load from the weblogic.jar file. * * @author Vineet Reynolds */","class WebLogicJMXLibClassLoader extends URLClassLoader {
    private static final Logger logger = Logger.getLogger(WebLogicJMXLibClassLoader.class.getName());

    public WebLogicJMXLibClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) {
        super(urls, parent, factory);
    }

    public WebLogicJMXLibClassLoader(URL[] urls, ClassLoader parent) {
        super(urls, parent);
    }

    public WebLogicJMXLibClassLoader(URL[] urls) {
        super(urls);
    }

    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        logger.log(Level.FINEST, ""Loading class: {0}"", name);
        return super.loadClass(name);
    }
}",1
WebModulesContainer.java,/** * Gets the modules count * @return The modules count */,"public int getModulesCount() {
        return modulesCount;
    }",1
WebMvcConfiguration.java,/** * Spring MVC use a default objectMapper. Objects passed to and returned from the controllers are converted to and from HTTP messages by HttpMessageConverter * instances. We must use our {{@link #objectMapper}} because of the subtypes.... So we declare two message converters * <ul> * <li>StringHttpMessageConverter to format the String sent by HTTP like a JSON object representation</li> * <li>MappingJackson2HttpMessageConverter to use our {{@link #objectMapper}}</li> * </ul>To declare a JacksonHttpMessageConvet */,"@Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //Add a converter for the String sent via HTTP
        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(Charset.forName(""UTF-8""));
        stringConverter.setWriteAcceptCharset(false);  // see SPR-7316
        converters.add(stringConverter);

        //Use our custom Jackson serializer
        MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(objectMapper);
        mappingJackson2HttpMessageConverter.setSupportedMediaTypes(supportedMediaTypes());
        converters.add(mappingJackson2HttpMessageConverter);

    }",1
WebPageImpl.java,/** * Get a new Infobox but do not add it to the page. Can be used for putting Infoboxes inside Infoboxes. * @param title The title of the desired Infobox * @return the contentNode of the newly created Infobox */,"protected final HTMLNode getContentBox(String title) {
		InfoboxNode infobox = mPM.getInfobox(title);
		return infobox.outer;
	}",1
WebRequestContext.java,/** * @see javax.servlet.ServletRequestWrapper#getParameterValues(java.lang.String) */,"public String[] getParameterValues(String name) 
	{
		Object value = this.getObjectParameter(name);
		
		if (value instanceof String) {
			return new String[] { (String)value };
		}
		
		List l = (List)value;
		
		return l == null
			? super.getParameterValues(name)
			: (String[])l.toArray(new String[0]);
	}",1
WebRequestTrackingTelemetryModule.java,/** * Initializes the telemetry module with the given telemetry configuration. * @param configuration The telemetry configuration. */,"@Override
    public void initialize(TelemetryConfiguration configuration) {
        try {
            telemetryClient = new TelemetryClient(configuration);
            isInitialized = true;
        } catch (Exception e) {
            InternalLogger.INSTANCE.error(
                    ""Failed to initialize telemetry module "" + this.getClass().getSimpleName() + "". Exception: %s."", e.getMessage());
        }
    }",1
WebResourceFactory.java,"/** * Creates a new client-side representation of a resource described by * the interface passed in the first argument. * * @param <C>                Type of the resource to be created. * @param resourceInterface  Interface describing the resource to be created. * @param target             WebTarget pointing to the resource or the parent of the resource. * @param ignoreResourcePath If set to true, ignores path annotation on the resource interface (this is used when creating *                           sub-resources) * @param headers            Header params collected from parent resources (used when creating a sub-resource) * @param cookies            Cookie params collected from parent resources (used when creating a sub-resource) * @param form               Form params collected from parent resources (used when creating a sub-resource) * @param invoker            Method invoker * @return Instance of a class implementing the resource interface that can * be used for making requests to the server. */","@SuppressWarnings(""unchecked"")
    public static <C> C newResource(final Class<C> resourceInterface,
                                    final WebTarget target,
                                    final boolean ignoreResourcePath,
                                    final MultivaluedMap<String, Object> headers,
                                    final List<Cookie> cookies,
                                    final Form form,
                                    final ClientMethodInvoker invoker) {

        return (C) Proxy.newProxyInstance(AccessController.doPrivileged(ReflectionHelper.getClassLoaderPA(resourceInterface)),
                new Class[]{resourceInterface},
                new WebResourceFactory(ignoreResourcePath ? target : addPathFromAnnotation(resourceInterface, target),
                        headers, cookies, form, invoker));
    }",1
WebResourceName.java,/** * Gets the value of the id property. * * @return *     possible object is *     {@link String } * */,"public String getId() {
        return id;
    }",1
WebResourceName.java,/** * Gets the value of the value property. * * @return *     possible object is *     {@link String } * */,"public String getvalue() {
        return value;
    }",1
WebResourcesBrowserInformationControl.java,/** * Browser information control for Web Resources. * */,"public class WebResourcesBrowserInformationControl extends
		BrowserInformationControl {

	public WebResourcesBrowserInformationControl(Shell parent,
			String symbolicFontName, ToolBarManager toolBarManager) {
		super(parent, symbolicFontName, toolBarManager);
	}

	@Override
	public IInformationControlCreator getInformationPresenterControlCreator() {
		// Hack: We don't wan't to have auto-enrichment when the mouse moves
		// into the hover,
		// but we do want F2 to persist the hover. The framework has no way to
		// distinguish the
		// two requests, so we have to implement this aspect.
		for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
			if (""canMoveIntoInformationControl"".equals(element.getMethodName()) //$NON-NLS-1$
					&& ""org.eclipse.jface.text.AbstractHoverInformationControlManager"".equals(element.getClassName())) //$NON-NLS-1$
				return null; // do not enrich bracket hover
		}
		return super.getInformationPresenterControlCreator();
	}

}",1
WebResourcesContext.java,"/** * Constructor for web resources context. * * @param htmlNode *            the HTML node which have triggers this provider. * @param resourceType *            the resource type (css, js, img); * @param hasExternalCSS */","public WebResourcesContext(IDOMNode htmlNode,
			WebResourcesFinderType resourceType, boolean hasExternalCSS) {
		this.htmlNode = htmlNode;
		this.htmlFile = null;
		this.resourceType = resourceType;
		this.hasExternalCSS = hasExternalCSS;
	}",1
WebResourcesMainPropertyPage.java,/** * Web resources Main page for project properties. * */,"public class WebResourcesMainPropertyPage extends PropertyPage implements
		IWorkbenchPropertyPage {

	public WebResourcesMainPropertyPage() {
	}

	protected Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		composite.setLayoutData(new GridData(4, 4, true, true));
		composite.setLayout(new GridLayout());
		return composite;
	}

}",1
WebRtcChannel.java,"/** * Type of channel in WebRTC communications (audio, video, or both). * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */","public enum WebRtcChannel {
	VIDEO_ONLY, AUDIO_ONLY, AUDIO_AND_VIDEO;

	public boolean getAudio() {
		switch (this) {
		case VIDEO_ONLY:
			return false;
		case AUDIO_ONLY:
			return true;
		case AUDIO_AND_VIDEO:
		default:
			return true;
		}
	}

	public boolean getVideo() {
		switch (this) {
		case VIDEO_ONLY:
			return true;
		case AUDIO_ONLY:
			return false;
		case AUDIO_AND_VIDEO:
		default:
			return true;
		}
	}
}",1
WebScarabWrapper.java,/** * Add a plugin to the proxy. IMPORTANT: call this before the proxy is actually started. * * @param plugin *            The plugin to add. */,"public void addPlugin(ProxyPlugin plugin) {
		plugins.add(plugin);
	}",1
WebScenarioObject.java,/** * Gets templateid. * * @return Value of templateid. */,"public Integer getTemplateid() {
        return templateid;
    }",1
WebScenarioObject.java,/** * Gets status. * * @return Value of status. */,"public Integer getStatus() {
        return status;
    }",1
WebScenarioObject.java,/** * Gets variables. * * @return Value of variables. */,"public String getVariables() {
        return variables;
    }",1
WebScenarioObject.java,/** * Sets new http_proxy. * * @param http_proxy New value of http_proxy. */,"public void setHttp_proxy(String http_proxy) {
        this.http_proxy = http_proxy;
    }",1
WebScenarioObject.java,/** * Gets nextcheck. * * @return Value of nextcheck. */,"public Long getNextcheck() {
        return nextcheck;
    }",1
WebSensorTest.java,/** * Unit test which is more kind of an integration test. The purpose of this test is to get early feedback on changes in * the number of issues. */,"@Test
  public void testSensor() throws Exception {
    DefaultInputFile inputFile = new DefaultInputFile(""key"", ""user-properties.jsp"")
      .setLanguage(WebConstants.LANGUAGE_KEY)
      .setType(InputFile.Type.MAIN)
      .initMetadata(new FileMetadata().readMetadata(new FileReader(new File(TEST_DIR, ""user-properties.jsp""))));

    tester.fileSystem().add(inputFile);

    sensor.execute(tester);

    String componentKey = inputFile.key();
    assertThat(tester.measure(componentKey, CoreMetrics.NCLOC).value()).isEqualTo(227);
    assertThat(tester.measure(componentKey, CoreMetrics.COMMENT_LINES).value()).isEqualTo(14);
    assertThat(tester.measure(componentKey, CoreMetrics.COMPLEXITY).value()).isEqualTo(1);

    assertThat(tester.cpdTokens(componentKey)).hasSize(224);

    assertThat(tester.highlightingTypeAt(componentKey, 1, 0)).containsOnly(TypeOfText.COMMENT);
    assertThat(tester.highlightingTypeAt(componentKey, 18, 0)).containsOnly(TypeOfText.COMMENT);
    assertThat(tester.highlightingTypeAt(componentKey, 19, 0)).containsOnly(TypeOfText.ANNOTATION);
    assertThat(tester.highlightingTypeAt(componentKey, 29, 17)).containsOnly(TypeOfText.STRING);
    assertThat(tester.highlightingTypeAt(componentKey, 29, 0)).containsOnly(TypeOfText.KEYWORD);

    assertThat(tester.allIssues()).hasSize(84);
  }",1
WebServiceResponse.java,/** * @return Returns the content. */,"public byte[] getContent()
    {
        if (content == null) 
        	return ""<NOOP/>"".getBytes();
        return content;
    }",1
WebSessionTrackingTelemetryModule.java,/** * Initializes the telemetry module. * * @param configuration The configuration to used to initialize the module. */,"@Override
    public void initialize(TelemetryConfiguration configuration) {
    }",1
WebSessionTrackingTelemetryModule.java,/** * End request processing. * This method checks if the session cookie should be updated before sent back to the client. * The session cookie is updated when the session is new or current session already expired. * * @param req The request to process * @param res The response to modify */,"@Override
    public void onEndRequest(ServletRequest req, ServletResponse res) {
    }",1
WebsiteChooserFragment.java,/** * Set the adapter data by copying the given data to a new object and removing already added website. * It will also sort the list by the most liked website first * * @param websites data to display */,"private void setAdapterData(List<Website> websites) {
        List<Website> websites1 = new ArrayList<>();
        websites1.addAll(websites);
        if (!websites1.isEmpty()) {
            if (!TextUtils.isEmpty(mMode) && !mMode.equals(BUNDLE_MODE_RESTORE)) {
                // We want to add some websites : remove duplicates or already added ones
                List<Website> savedWebsites = SpStorage.getWebsites(getActivity());

                // We cannot iterate on a list and remove item at the same time, need an array
                for (Website website : websites1.toArray(new Website[websites1.size()])) {
                    if (savedWebsites.contains(website)) {
                        websites1.remove(website);
                    }
                }
            }

            Collections.sort(websites1, new Comparator<Website>() {
                @Override
                public int compare(Website website, Website website2) {
                    if (website.like > website2.like) {
                        return -1;
                    } else if (website.like < website2.like) {
                        return 1;
                    }
                    return 0;
                }
            });

            mAdapter.setData(websites1);
        }
    }",1
WebsitePage.java,/** * Validate inner data to prevent usage when using it */,"public void validate() {
        if(TextUtils.isEmpty(slug)){
            slug = ""local-"" + name;
        }
        if(content == null){
            content = new Content();
        }
    }",1
WebSocketChannel.java,/** * The number of bytes queued to be sent */,"public int getBufferedAmount() {
        return this.bufferedAmount;
    }",1
WebSocketConnection.java,/** * Create WebSockets background writer. */,"protected void createWriter() {

      mWriterThread = new HandlerThread(""WebSocketWriter"");
      mWriterThread.start();
      mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);

      if (DEBUG) Log.d(TAG, ""WS writer created and started"");
   }",1
WebSocketController.java,"/** * Opens a websocket for the given user nation and their current home region. * * @param user nation that is opening the websocket. * @param userRegion name of the region the user currently resides in. * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt. * * @return websocket */","public WebSocket<JsonNode> index(String user, String userRegion, boolean reconnect) {
		if (user.isEmpty() || userRegion.isEmpty()) return null;
		return new NationStatesWebSocket(this.getDatabase(), new DefaultPage(), sanitizeName(user), sanitizeName(userRegion), reconnect);
	}",1
WebSocketController.java,"/** * Opens a websocket for the given user nation and their current home region, and the region they are viewing the regional controls page for. * * @param nation nation that is opening the websocket. * @param userRegion name of the region the user currently resides in. * @param adminRegion the name of the region that the user currently is looking at in the regional controls. * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt. * * @return websocket */","public WebSocket<JsonNode> recruitmentAdmin(String nation, String userRegion, String adminRegion, boolean reconnect) {
		if (nation.isEmpty() || userRegion.isEmpty() || adminRegion.isEmpty()) return null;
		return new NationStatesWebSocket(this.getDatabase(), new RecruitmentAdministrationPage(adminRegion, getDatabase().getRegionId(adminRegion)), sanitizeName(nation), sanitizeName(userRegion), reconnect);
	}",1
WebSocketEmulatedDecoderImpl.java,/* * Processing state machine */,"enum DecodingState {
        START_OF_FRAME,
        READING_TEXT_FRAME,
        READING_COMMAND_FRAME,
        READING_BINARY_FRAME_HEADER,
        READING_BINARY_FRAME,
        READING_PING_FRAME
    };",1
WebSocketExtensionFactory.java,/** * Creates a new instance of WebSocketExtensionFactory. It uses the default {@link ClassLoader} to load * {@link WebSocketExtensionFactorySpi} objects that are registered using META-INF/services. * * @return WebSocketExtensionFactory */,"public static WebSocketExtensionFactory newInstance() {
        ServiceLoader<WebSocketExtensionFactorySpi> services = load(WebSocketExtensionFactorySpi.class);
        return newInstance(services);
    }",1
WebSocketFrameType.java,/** * Type of web socket frames */,"public enum WebSocketFrameType {
    TEXT, BINARY, PING, PONG, CLOSE, CONTINUATION
}",1
WebSocketHandlerAdapter.java,/** * Process connect request to uri and protocol specified */,"@Override
    public void processConnect(WebSocketChannel channel, WSURI location, String[] protocols) {
        nextHandler.processConnect(channel, location, protocols);
    }",1
WebSocketHandlerAdapter.java,/** * Disconnect the WebSocket */,"@Override
    public synchronized void processClose(WebSocketChannel channel, int code, String reason) {
        nextHandler.processClose(channel, code, reason);        
    }",1
WebSocketHandshakeObject.java,/** * @param name the name to set */,"public void setName(String name) {
        this.name = name;
    }",1
WebSocketNativeBalancingHandlerTest.java,/* * wait receive balancer message for kaazing gateway */,"@Test
    public void testWaitBalancerMessage() throws URISyntaxException {

        Mockery context = new Mockery();
        final WebSocketHandler nextHandler = context.mock(WebSocketHandler.class);
        final WebSocketHandlerListener listener = context.mock(WebSocketHandlerListener.class);
        final String[] requestedProtocols = new String[] { ""x-kaazing-handshake"" };

        context.checking(new Expectations() {
            {
                oneOf(nextHandler).setListener(with(aNonNull(WebSocketHandlerListener.class)));
                will(saveParameter(""listener"", 0));
                oneOf(nextHandler).processConnect(with(aNonNull(WebSocketChannel.class)), with(aNonNull(WSURI.class)), with(equal(requestedProtocols)));
                will(new CustomAction(""will fire connectionOpen"") {

                    @Override
                    public Object invoke(Invocation invocation) {
                        WebSocketHandlerListener listener = (WebSocketHandlerListener)lookup(""listener"");
                        WebSocketChannel channel = (WebSocketChannel)invocation.getParameter(0);
                        listener.connectionOpened(channel, requestedProtocols[0]);
                        return null;
                    }
                });
               
            }
        });

        WSURI uri = new WSURI(""ws://locationhost:8001/echo"");

        WebSocketChannel channel = new WebSocketNativeChannel(uri);

        WebSocketNativeBalancingHandler handler = new WebSocketNativeBalancingHandler();
        handler.setNextHandler(nextHandler);
        handler.setListener(listener);

        handler.processConnect(channel, uri, requestedProtocols);
        context.assertIsSatisfied();
    }",1
WebSocketNativeEncoderImpl.java,"/** * Performs an in-situ masking of the readable buf bytes. * Preserves the position of the buffer whilst masking all the readable bytes, * such that the masked bytes will be readable after this invocation. * * @param buf   the buffer containing readable bytes to be masked. * @param mask  the mask to apply against the readable bytes of buffer. */","public static void mask(WrappedByteBuffer buf, int mask) {
        // masking is the same as unmasking due to the use of bitwise XOR.
        unmask(buf, mask);
    }",1
WebsocketRequestBuilderDefault.java,/** * The ExecutorService to use to * send events to the client. */,"protected ExecutorService getThreadExecutorForClientEvents() {

        if(this.threadExecutorForClientEvents == null) {
            ThreadFactory threadFactory = getThreadExecutorForClientEventsThreadThreadFactory();
            if(threadFactory != null) {
                this.threadExecutorForClientEvents =
                        Executors.newFixedThreadPool(getThreadExecutorForClientEventsThreadNumber(), threadFactory);
            } else {
                this.threadExecutorForClientEvents = Executors.newFixedThreadPool(getThreadExecutorForClientEventsThreadNumber());
            }
        }

        return this.threadExecutorForClientEvents;
    }",1
WebsocketThread.java,/** * startWS - public method to initiate the websocket * @return websocket creation status */,"public boolean startWS(){
		boolean status = false;
		
		//Establish the websocket
		try {
			System.out.println(""WebsocketThread.startWS(): creating WebsocketClientEndpoint with URI: <"" + 
																									URIstring + "">...."");
			//save the state of web socket before initiating
			//open is an async call, notification may come before setting state
			currWSstateLock.lock();
	        currWSstate = WSstate.WS_INITIATED;
	        currWSstateLock.unlock();
	        
	        //initiate WS
			clientEndPoint = new WebsocketClientEndpoint(new URI(URIstring), this);
			status = true;
			
			//set the running status
			runStatus = true;
		} catch (URISyntaxException e) {
			System.out.println(""WebsocketThread.startWS(): ERROR: URISyntaxException on WebsocketClientEndpoint"");
			e.printStackTrace();
		}
		return status;
	}",1
WebsocketThread.java,/** * getInstrumentString - private method to create instrument string from instrument list * @param instrumentList * @return instrumentString */,"private String getInstrumentString(List<String> instrumentList){
		StringBuilder stringBuilder = new StringBuilder();
		for(int i = 0; i < instrumentList.size(); i++){
			stringBuilder.append(instrumentList.get(i));
			if(i < (instrumentList.size() - 1)){
				stringBuilder.append("","");
			}
		}
		
		String instrumentString = stringBuilder.toString();
		System.out.println(""WebsocketThread.getInstrumentString(): instrumentString: ["" + instrumentString + ""]"");
		return instrumentString;
	}",1
WebsocketThread.java,/** * fireDataMissTimerOnWSsubscribe - private method to fire data miss timer on subscribe */,"private void fireDataMissTimerOnWSsubscribe(){
        //start Timer for Web Socket Data miss Check after subscribe
        if(dataTimer != null){
        	dataTimer.cancel();
		}
        dataTimer = new Timer(""WS Data Miss Timer"");
        dataTimer.schedule(new TimerTask() {			
			@Override
			public void run() {
				if(currWSstate == WSstate.WS_MODE_SWITCHED){
					System.out.println(""WebsocketThread.fireDataMissTimerOnWSsubscribe().new TimerTask().run(): ERROR: "" +
							""Streaming Quote WS Data Miss Timer Fired after subscribe, notifying session notifier !!!"");
					//Notify Data Missed after Subscribe
					notifyWsDataMissedAfterSubscribe();
				} else{
					//Data started, let the timer expire
					System.out.println(""WebsocketThread.fireDataMissTimerOnWSsubscribe()new TimerTask().run(): "" + 
														""WS data getting pushed in, curr state["" + currWSstate + ""]"");
				}
			}
		}, dataTimeDelay);
	}",1
WebSocketWebResource.java,/** * Gets a caller id (IP + role) * * @return the web service caller identification */,"public String clientAppId() {
        if (clientId != null && service().getConfig().isAuthenticationEnabled()) {
            try {
                clientId = service().getAuthenticationService().authenticateHttpRequest(httpRequest);
            } catch (AuthenticationException e) {
                throw new RestException(Status.UNAUTHORIZED, ""Failed to get clientId from request"");
            }
        } else {
            throw new RestException(Status.UNAUTHORIZED, ""Failed to get auth data from the request"");
        }
        return clientId;
    }",1
WebSocketWebResource.java,/** * Checks if user is authorized to produce/consume on a given topic * * @param topic * @return * @throws Exception */,"protected boolean isAuthorized(DestinationName topic) throws Exception {
        if (service().isAuthorizationEnabled()) {
            String authRole = clientAppId();
            return service().getAuthorizationManager().canLookup(topic, authRole);
        }
        return true;
    }",1
WebsockifyProxyHandler.java,/** * Sets the content type header for the HTTP Response * * @param response *            HTTP response * @param file *            file to extract content type */,"private void setContentTypeHeader(HttpResponse response, File file) {
        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
        response.setHeader(HttpHeaders.Names.CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
    }",1
WebsockifyServer.java,"/** * Validates that a keystore with the given parameters exists and can be used for an SSL context. * @param keystore - path to the keystore file * @param password - password to the keystore file * @param keyPassword - password to the private key in the keystore file * @return null if valid, otherwise a string describing the error. */","public void validateKeystore ( String keystore, String password, String keyPassword )
		throws KeyManagementException, UnrecoverableKeyException, IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException
	{
		WebsockifySslContext.validateKeystore(keystore, password, keyPassword);
	}",1
WebTelemetryTests.java,/** * Sends GET requests to server and expects that will telemetry from app insights and it will include the correct information about the request * @throws Exception */,"@Test
    public void testHttpRequestCommonProperties() throws Exception {
        List<TelemetryItem> expectedTelemetriesForRunId = getExpectedTelemetriesForRunId(testRequestCommonPropertiesRunId);
        List<TelemetryItem> realTelemetries = applicationTelemetryManager.getApplicationTelemetries(testRequestCommonPropertiesRunId, 1);

        Assert.assertEquals(1, realTelemetries.size());
        Assert.assertEquals(expectedTelemetriesForRunId.get(0), realTelemetries.get(0));
    }",1
WebURL.java,/** * @return unique document id assigned to this Url. */,"public int getDocid() {
        return docid;
    }",1
WebUserTelemetryInitializer.java,/** * Initializes the properties of the given telemetry. * * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize. */,"@Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        UserContext userContext = telemetry.getContext().getUser();

        if (!CommonUtils.isNullOrEmpty(userContext.getId())) {
            return;
        }

        RequestTelemetry requestTelemetry = ThreadContext.getRequestTelemetryContext().getHttpRequestTelemetry();
        UserContext requestUserContext = requestTelemetry.getContext().getUser();
        if (requestUserContext == null) {
            return;
        }

        userContext.setId(requestUserContext.getId());

        Date requestUserAcquisitionDate = requestUserContext.getAcquisitionDate();
        userContext.setAcquisitionDate(requestUserAcquisitionDate);
    }",1
WebViews.java,/** * Indicates whether the specified DOM event can be converted to a {@link HyperlinkEvent}. * * @param domEvent *            the DOM-{@link Event} * @return true if the event's {@link Event#getType() type} has an equivalent {@link EventType EventType} */,"public static boolean canConvertToHyperlinkEvent(Event domEvent) {
		return StaticDomEventConverter.canConvertToHyperlinkEvent(domEvent);
	}",1
WebxmlTopicReader.java,/** * Read topics of TREC Web Tracks from 2009 to 2014 including: * topics.web.1-50.txt * topics.web.51-100.txt * topics.web.101-150.txt * topics.web.151-200.txt * topics.web.201-250.txt * topics.web.251-300.txt * @return SortedMap where keys are query/topic IDs and values are title portions of the topics * @throws IOException */,"@Override
  public SortedMap<Integer, String> read() throws IOException {
    SortedMap<Integer, String> map = new TreeMap<>();
    List<String> lines = Files.readAllLines(topicFile, StandardCharsets.UTF_8);

    String number = """";
    String query = """";

    for (String line : lines) {
      line = line.trim();
      if (line.startsWith(""<topic""))
        number = extract(line, ""number"");
      if (line.startsWith(""<query>"") && line.endsWith(""</query>""))
        query = line.substring(7, line.length() - 8).trim();
      if (line.startsWith(""</topic>""))
        map.put(Integer.parseInt(number), query);
    }

    lines.clear();
    return map;
  }",1
WeekView.java,"/** * Get the interpreter which provides the text to show in the header column and the header row. * @return The date, time interpreter. */","public DateTimeInterpreter getDateTimeInterpreter() {
        if (mDateTimeInterpreter == null) {
            mDateTimeInterpreter = new DateTimeInterpreter() {
                @Override
                public String interpretDate(Calendar date) {
                    try {
                        SimpleDateFormat sdf = mDayNameLength == LENGTH_SHORT ? new SimpleDateFormat(""EEEEE M/dd"", Locale.getDefault()) : new SimpleDateFormat(""EEE M/dd"", Locale.getDefault());
                        return sdf.format(date.getTime()).toUpperCase();
                    } catch (Exception e) {
                        e.printStackTrace();
                        return """";
                    }
                }

                @Override
                public String interpretTime(int hour) {
                    Calendar calendar = Calendar.getInstance();
                    calendar.set(Calendar.HOUR_OF_DAY, hour);
                    calendar.set(Calendar.MINUTE, 0);

                    try {
                        SimpleDateFormat sdf = DateFormat.is24HourFormat(getContext()) ? new SimpleDateFormat(""HH:mm"", Locale.getDefault()) : new SimpleDateFormat(""hh a"", Locale.getDefault());
                        return sdf.format(calendar.getTime());
                    } catch (Exception e) {
                        e.printStackTrace();
                        return """";
                    }
                }
            };
        }
        return mDateTimeInterpreter;
    }",1
WeekView.java,/** * Set corner radius for event rect. * * @param eventCornerRadius the radius in px. */,"public void setEventCornerRadius(int eventCornerRadius) {
        mEventCornerRadius = eventCornerRadius;
    }",1
WeekView.java,/** * Returns the last visible day in the week view. * @return The last visible day in the week view. */,"public Calendar getLastVisibleDay() {
        return mLastVisibleDay;
    }",1
WeekView.java,/** * Get the scrolling speed factor in horizontal direction. * @return The speed factor in horizontal direction. */,"public float getXScrollingSpeed() {
        return mXScrollingSpeed;
    }",1
WeekView.java,/** * Sets the speed for horizontal scrolling. * @param xScrollingSpeed The new horizontal scrolling speed. */,"public void setXScrollingSpeed(float xScrollingSpeed) {
        this.mXScrollingSpeed = xScrollingSpeed;
    }",1
WeekView.java,"/** * Get the ""now"" line color. * @return The color of the ""now"" line. */","public int getNowLineColor() {
        return mNowLineColor;
    }",1
WeekView.java,/** * Set whether the week view should fling vertically. * @return True if it should have vertical fling enabled. */,"public void setVerticalFlingEnabled(boolean enabled) {
        mVerticalFlingEnabled = enabled;
    }",1
WeekView.java,/** * Get scroll duration * @return scroll duration */,"public int getScrollDuration() {
        return mScrollDuration;
    }",1
WeekView.java,/** * Refreshes the view and loads the events again. */,"public void notifyDatasetChanged(){
        mRefreshEvents = true;
        invalidate();
    }",1
WeexUiTestCaseTCAHrefEvent.java,/** * findMyCaseByText */,"public View findMyCaseByText(String caseText){
        if (mCaseListIndexView.size() == 0) return null;

        WXTextView view = null;
        for(int i=0; i<mCaseListIndexView.size();i++){

            view = (WXTextView)mCaseListIndexView.get(i);

            if (view.getText().toString().toLowerCase().contains(caseText.toLowerCase())){
                return view;
            }

        }
        return view;
    }",1
WeexUiTestCaseTCAHrefStyle.java,/** * get tc list by text * @param byText * @return * @throws InterruptedException */,"public ArrayList<View> getTestCaseListViewByText(String byText) throws InterruptedException {
        Log.e(""TestScript_Guide"", ""byText =="" + byText);

        if(TextUtils.isEmpty(byText)){
            return null;
        }
        ArrayList<View> outViews = new ArrayList<View>();

        mViewGroup.findViewsWithText(outViews, byText, View.FIND_VIEWS_WITH_TEXT);

        for (View view :  outViews){
            String viewText = ((WXTextView)view).getText().toString();
            Log.e(TAG, ""viewText =="" + viewText);


        }
        return outViews;
    }",1
Weightings.java,/** * @param func * @return Strategy that sets the weight to the difference between the max *  value of all clients and the client value. */,"public static <C> WeightingStrategy<C> inverseMax(Func1<C, Integer> func) {
        return new InverseMaxWeightingStrategy<C>(func);
    }",1
WelcomeFile.java,/** * Sets the value of the value property. * * @param value *     allowed object is *     {@link String } * */,"public void setvalue(String value) {
        try {
            support.fireVetoableChange(""value"",value, value);
        } catch (PropertyVetoException _x) {
            return;
        }
        this.value = value;
    }",1
WellKnownTypeUtils.java,"/** * @return a Kind corresponding to the JSON number type and the given format. TODO (guptasu): For *     all below types, ensure defaults are right. TODO (guptasu): For all below types, add errors *     for unknown types. */","private static Kind getNumberKind(String format) {
    if (Strings.isNullOrEmpty(format)) {
      return Kind.TYPE_DOUBLE;
    }
    switch (format) {
      case ""float"":
        return Kind.TYPE_FLOAT;
      case ""double"":
        return Kind.TYPE_DOUBLE;
      default:
        return Kind.TYPE_DOUBLE;
    }
  }",1
WePayError.java,"/** * Known error codes.  Because wepay might add additional codes, this is not guaranteed to be an exhaustive list. */","public enum WePayError {
	invalid_request,
	access_denied,
	invalid_scope,
	invalid_client,
	processing_error;
}",1
WFSIDCCAPS.java,/** * @see #compound */,"public boolean isCompound() {
		return compound.booleanValue();
	}",1
WFSIDCCAPS.java,/** * @see #compound */,"public void setCompound(final boolean compound) {
		this.compound.set(compound);
	}",1
WFSIDCCAPS.java,/** * @see #readTracks */,"public Set<IDCTrack> getReadTracks() {
		return XfsConstants.of(readTracks, IDCTrack.class);
	}",1
WFSIDCCAPS.java,/** * @see #chipProtocols */,"public Set<IDCChipProtocol> getChipProtocols() {
		return XfsConstants.of(chipProtocols, IDCChipProtocol.class);
	}",1
WFSIDCCAPS.java,/** * @see #secType */,"public void setSecType(final IDCSecType secType) {
		this.secType.set((int) secType.getValue());
	}",1
WFSIDCCAPS.java,/** * @see #readWriteAccessFollowingEject */,"public void setReadWriteAccessFollowingEject(final boolean readWriteAccessFollowingEject) {
		this.readWriteAccessFollowingEject.set(readWriteAccessFollowingEject);
	}",1
WFSIDCCAPS.java,/** * @see #memoryChipProtocols */,"public Set<IDCMemoryChipProtocol> getMemoryChipProtocols() {
		// FIXME:
		return null;
	}",1
WFSIDCCARDDATA.java,/** * @param pCardData *            pointer to card data structure */,"public WFSIDCCARDDATA(final XfsVersion xfsVersion, final Pointer pCardData) {
		this(xfsVersion);
		assignBuffer(pCardData);
	}",1
WfsIDCStatus.java,/** * @see #device */,"public IDCDeviceState getDevice() {
		return XfsConstants.valueOf(device, IDCDeviceState.class);
	}",1
WfsIDCStatus.java,/** * @see #powerSaveRecoveryTime */,"public void setPowerSaveRecoveryTime(final int powerSaveRecoveryTime) {
		this.powerSaveRecoveryTime.set(powerSaveRecoveryTime);
	}",1
WFSPINCAPS.java,/** * {@link #pinFormats} */,"public Set<PINFormat> getPINFormats() {
		return XfsConstants.of(pinFormats, PINFormat.class);
	}",1
WFSPINCAPS.java,/** * {@link #autoBeep} */,"public void setAutoBeep(final Set<PINAutoBeep> autoBeep) {
		this.autoBeep.set((int) Bitmask.of(autoBeep));
	}",1
WFSPINCAPS.java,/** * {@link #hsmVendor} */,"public String getHSMVendor() {
		return hsmVendor.toString();
	}",1
WFSPINCAPS.java,/** * {@link #rsaKeyCheckModes} */,"public Set<PINRSAKeyCheckMode> getRSAKeyCheckModes() {
		return XfsConstants.of(rsaKeyCheckModes, PINRSAKeyCheckMode.class);
	}",1
WFSPINCAPS.java,/** * {@link #emvImportSchemes} */,"public Pointer getEMVImportSchemes() {
		return emvImportSchemes;
	}",1
WFSPINCAPS.java,/** * {@link #keyImportThroughParts} */,"public boolean isKeyImportThroughParts() {
		return keyImportThroughParts.booleanValue();
	}",1
WFSPINCAPS.java,/** * {@link #keyBlockImportFormats} */,"public Set<PINKeyBlockImportFormat> getKeyBlockImportFormats() {
		return XfsConstants.of(keyBlockImportFormats, PINKeyBlockImportFormat.class);
	}",1
WFSPINCAPS.java,/** * {@link #powerSaveControl} */,"public boolean isPowerSaveControl() {
		return powerSaveControl.booleanValue();
	}",1
WFSPINFDK.java,/** * @see #xPosition */,"public int getXPosition() {
		return xPosition.intValue();
	}",1
WFSPTRCAPS.java,/** * Specifies whether the logical device is part of a compound physical * device. */,"public boolean isCompound() {
		return compound.booleanValue();
	}",1
WFSPTRCAPS.java,"/** * Specifies the back image color formats supported by this device, as a * combination of following flags (empty if not supported): * {@link PTRImageColor} * * @since 3.00 */","public Set<PTRImageColor> getBackImageColorFormat() {
		return XfsConstants.of(backImageColorFormat, PTRImageColor.class);
	}",1
WFSPTRCAPS.java,/** * Specifies which guidance lights are available. * * @since 3.10 */,"public DWORD getGuidLights() {
		return guidLights;
	}",1
WFSPTRCAPS.java,"/** * Specifies the number of seconds before the device will automatically * retract the presented media. If the command that generated the media is * still active when the media is automatically retracted, the command will * complete with a WFS_ERR_PTR_MEDIARETRACTED error. If the device does not * retract media automatically this value will be zero. * * @since 3.10 */","public int getAutoRetractPeriod() {
		return autoRetractPeriod.intValue();
	}",1
WFSPTRCAPS.java,/** * Specifies on which sides of the media this device can print as one of the * following values: * * @since 3.20 */,"public PTRPrintSides getPrintSides() {
		return XfsConstants.valueOf(printSides, PTRPrintSides.class);
	}",1
WFSPTRSTATUS.java,/** * Specifies the status of the printer imaging lamp as one of the following * values: {@link PTRLamp} * * @since 2.0 */,"public PTRLamp getLamp() {
		return XfsConstants.valueOf(lamp, PTRLamp.class);
	}",1
Whitelist.java,"/** Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to URLs with the defined protocol. <p/> E.g.: <code>addProtocols(""a"", ""href"", ""ftp"", ""http"", ""https"")</code>  @param tag       Tag the URL protocol is for @param key       Attribute key @param protocols List of valid protocols @return this, for chaining */","public Whitelist addProtocols(String tag, String key, String... protocols) {
        Validate.notEmpty(tag);
        Validate.notEmpty(key);
        Validate.notNull(protocols);

        TagName tagName = TagName.valueOf(tag);
        AttributeKey attrKey = AttributeKey.valueOf(key);
        Map<AttributeKey, Set<Protocol>> attrMap;
        Set<Protocol> protSet;

        if (this.protocols.containsKey(tagName)) {
            attrMap = this.protocols.get(tagName);
        } else {
            attrMap = new HashMap<AttributeKey, Set<Protocol>>();
            this.protocols.put(tagName, attrMap);
        }
        if (attrMap.containsKey(attrKey)) {
            protSet = attrMap.get(attrKey);
        } else {
            protSet = new HashSet<Protocol>();
            attrMap.put(attrKey, protSet);
        }
        for (String protocol : protocols) {
            Validate.notEmpty(protocol);
            Protocol prot = Protocol.valueOf(protocol);
            protSet.add(prot);
        }
        return this;
    }",1
WhoisListener.java,/** * * @param event */,"@Override
    public void onWhois(WhoisEvent event) {
        if (ircBot.whoisSenders.isEmpty()) {
            return;
        }
        CommandSender sender = ircBot.whoisSenders.remove(0);

        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""----[ "" + ChatColor.WHITE + ""Whois"" + ChatColor.LIGHT_PURPLE + "" ]----"");
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Nick: "" + ChatColor.WHITE + event.getNick());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Username: "" + ChatColor.WHITE + event.getLogin() + ""@"" + event.getHostname());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Real name: "" + ChatColor.WHITE + event.getRealname());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Server: "" + ChatColor.WHITE + event.getServer());
        User user = null;
        for (Channel channel : ircBot.getBot().getUserBot().getChannels()) {
            for (User u : channel.getUsers()) {
                if (u.getNick().equalsIgnoreCase(event.getNick())) {
                    user = u;
                    break;
                }
            }
        }
        if (user != null) {
            if (user.isAway()) {
                sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Away: "" + ChatColor.WHITE + user.getAwayMessage());
            }
        }
        if (!event.getChannels().isEmpty()) {
            StringBuilder sb = new StringBuilder();
            for (Object channel : (List<String>) event.getChannels()) {
                sb.append("" "");
                sb.append(channel);
            }
            sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Currently on:"" + ChatColor.WHITE + sb.toString());
        }
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Idle: "" + ChatColor.WHITE + secondsToTime(event.getIdleSeconds()));
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""Online since: "" + ChatColor.WHITE + secondsToDate(event.getSignOnTime()));
        sender.sendMessage(ChatColor.LIGHT_PURPLE + ""----[ "" + ChatColor.WHITE + ""End Whois"" + ChatColor.LIGHT_PURPLE + "" ]----"");
    }",1
WholeColumnFamilyIterator.java,"/** * @param currentRow All keys have this in their row portion (do not modify!). * @param keys       One key for each key in the row, ordered as they are given by the source iterator (do not modify!). * @param values     One value for each key in keys, ordered to correspond to the ordering in keys (do not modify!). * @return true if we want to keep the row, false if we want to skip it */","protected boolean filter(Text currentRow, Collection<Map.Entry<Key,Value>> keysValues) {
        return true;
    }",1
WhtsExtension.java,/** * * @param object */,"private void readData() {

		if (mManager == null)
			return;
		
		dashIcon=R.drawable.ic_extension_whts;

		int mCount = mManager.getmCount();
		LOGD(TAG,""count=""+mCount);

		if (mCount > 0) {
			dashVisible = true;

			dashStatus = """" + mCount;
			
			Resources res = getResources();
			String book = res.getQuantityString(R.plurals.notifications,
					mCount, mCount);
			dashTitle = book;
		
			ArrayList<MessageWht> msgs = mManager.getmMsgs();
			if (msgs != null) {
				StringBuilder sb = new StringBuilder();
				String and = """";
				
				for (MessageWht msg:msgs) {
						sb.append(and);
						sb.append(msg.getText());
						and=""\n"";
				}
				
				dashSubtitle=sb.toString();
			}

		} else {
			dashVisible = false;
		}

	}",1
WideDynamicMode.java,"/** * <p>Java class for WideDynamicMode. * * <p>The following schema fragment specifies the expected content contained within this class. * <p> * <pre> * &lt;simpleType name=""WideDynamicMode""&gt; *   &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}string""&gt; *     &lt;enumeration value=""OFF""/&gt; *     &lt;enumeration value=""ON""/&gt; *   &lt;/restriction&gt; * &lt;/simpleType&gt; * </pre> * */","@XmlType(name = ""WideDynamicMode"")
@XmlEnum
public enum WideDynamicMode {

    OFF,
    ON;

    public String value() {
        return name();
    }

    public static WideDynamicMode fromValue(String v) {
        return valueOf(v);
    }

}",1
WidgetBean.java,/** * We create the {@link JpaWidgetDao} */,"@PostConstruct
    @SuppressWarnings(""unused"")
    private void initialize() {
        widgetDao = new JpaWidgetDao(em);
    }",1
WidgetBean.java,/** * @param id *        the Widget id * @return the found Widget */,"public final Widget findById(final int id) {
        return widgetDao.findById(id);
    }",1
WidgetButtonNextPage.java,/** * Draws this button to the screen. */,"@Override
	public void drawButton(Minecraft par1Minecraft, int par2, int par3)
	{
		if (this.visible)
		{
			boolean flag = par2 >= this.xPosition && par3 >= this.yPosition && par2 < this.xPosition + this.width && par3 < this.yPosition + this.height;
			GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
			par1Minecraft.getTextureManager().bindTexture(bookGui);
			int k = 0;
			int l = 192;

			if (flag)
			{
				k += 23;
			}

			if (!this.nextPage)
			{
				l += 13;
			}

			this.drawTexturedModalRect(this.xPosition, this.yPosition, k, l, 23, 13);
		}
	}",1
WidgetFrequencyDomainType.java,/** * @return    The row count for Waveform View. */,"public int getRowCount() {
		
		return Integer.parseInt(rowCountTextfield.getText());
		
	}",1
WidgetHistogramXaxisType.java,"/** * Checks if the axis mode is ""normal"" or ""locked center"" * * @return    True if the axis mode is ""locked center"" */","public boolean isAxisCentered() {
		
		return axisTypeCombobox.getSelectedItem().toString().equals(""Locked Center"");
		
	}",1
WidgetHistogramXaxisType.java,/** * Checks if the axis maximum should be automatic. This should only be called if isAxisCentered() returns false. * * @return    True if the maximum should be automatic. */,"public boolean isMaximumAutomatic() {
		
		return maxCheckbox.isSelected();
		
	}",1
WidgetHistogramXaxisType.java,/** * Gets the axis maximum value. This should only be called if isAxisCentered() returns false and isMaximumAutomatic() returns false. * * @return    The maximum value for this axis. */,"public float getMaximumValue() {
		
		return Float.parseFloat(maxTextfield.getText());
		
	}",1
WidgetHistogramYaxisType.java,/** * @return    True if frequency should be shown. */,"public boolean isFrequencyShown() {
		
		return axisTypeCombobox.getSelectedItem().toString().equals(""Frequency"") || axisTypeCombobox.getSelectedItem().toString().equals(""Both"");
		
	}",1
WidgetMarketplaceController.java,/** * Views the marketplace tab with category results * @param model * @param referringPageId * @param category * @param offset * @return */,"@RequestMapping(value = { ""category/{category}"" }, method = RequestMethod.GET)
	public String viewCategory(Model model,
			@RequestParam String referringPageId,
			@PathVariable String category,
			@RequestParam(required = false, defaultValue = ""0"") int offset) {

		final String view = ViewNames.ADD_WIDGET_MARKETPLACE;

		User user = userService.getAuthenticatedUser();
		widgetStoreModelHelper(model, referringPageId, user, view);

        try {
            if(category.equals(""0"")){
                model.addAttribute(ModelKeys.WIDGETS, marketplaceService
                    .getWidgetsByFreeTextSearch("""", offset, getPageSize()));
                model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
            }else{
                model.addAttribute(ModelKeys.WIDGETS, marketplaceService.getWidgetsByCategory(category, offset, getPageSize()));
                model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
                model.addAttribute(ModelKeys.SELECTED_CATEGORY, category);
            }
		} catch (Exception e) {
			model.addAttribute(ModelKeys.ERROR_MESSAGE, ""Marketplace not available"");
		}",1
WidgetMarketplaceController.java,/* * Add common model attributes to the model * * @param model *            Model to add to * @param referringPageId *            Page to refer back to * @param user *            Current authenticated User */,"private void widgetStoreModelHelper(Model model, String referringPageId,
			User user, String view) {
		model.addAttribute(ModelKeys.REFERRING_PAGE_ID, referringPageId);
		ControllerUtils.addNavItemsToModel(view, model, referringPageId, user);
	}",1
WidgetMatcherFactory.java,/** * Matches a perspective with the specified id. * * @param id the id of the perspective. * @return a matcher. * @since 2.0 */,"public static org.hamcrest.Matcher withPerspectiveId(java.lang.String id) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveId.withPerspectiveId(id);
  }",1
WidgetMatcherFactory.java,/** * Matches a perspective with the specified label. * * @param label the label of the perspective. * @return a matcher. * @since 2.0 */,"public static org.hamcrest.Matcher withPerspectiveLabel(java.lang.String label) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveLabel.withPerspectiveLabel(label);
  }",1
WidgetPreferenceActivity.java,/** * Send an intent to update the widget. */,"private void updateWidget(boolean online) {
        Intent updateIntent = new Intent(android.appwidget.AppWidgetManager.ACTION_APPWIDGET_UPDATE,
                Uri.EMPTY, this, Widget.class);
        updateIntent.putExtra(Widget.LOAD_DATA_KEY, online);
        sendBroadcast(updateIntent);
    }",1
WidgetProviderService.java,/** * Gets the object that represents the metadata about the widget for * the viewer in the current context * @param viewer the current logged in user * @param context the context identifier for where the widget is displayed (e.g. regionwidget id) * @param widget the default widget * @return valid widget */,"Widget getWidget(User viewer, String context, Widget widget);
}",1
WidgetScreen.java,/** * Updates the widget screen buffer using the widgetBuffer sent by a widget. * * @param widgetBuffer the buffer sent by a widget * @param sessionId the sessionId of the sender; used to determine which part of the screen to *        update * @return the updated widget screen buffer */,"public byte[] updateScreenBuffer(byte[] widgetBuffer, int sessionId) {
    for (int i = 0; i < widgets.length; i++) {
      if ((widgets[i] != null) && (sessionId == sessionIds[i])) {
        System.arraycopy(widgetBuffer, 0, screenBuffer, i * BUFFER_LENGTH, BUFFER_LENGTH);
        break;
      }
    }
    
    return screenBuffer;
  }",1
WidgetSpace.java,/** * * @param widgetView * @param dummyViewId * @return whether the dummy view is replaced by listview */,"ListView postListView(AppWidgetHostView widgetView, int dummyViewId) {
            ListView lv = new ListView(getContext());
            lv.setCacheColorHint(0);

            if (replaceView(widgetView, dummyViewId, lv))
                return lv;
            else
                return null;
        }",1
WidgetSpace.java,/** * Register receivers given by this workspace */,"public void registerProvider() {
        final Context context = getContext();

        IntentFilter filter = new IntentFilter();
        filter.addAction(LauncherIntent.Action.ACTION_START_FRAME_ANIMATION);
        filter.addAction(LauncherIntent.Action.ACTION_STOP_FRAME_ANIMATION);
        filter.addAction(LauncherIntent.Action.ACTION_START_TWEEN_ANIMATION);
        context.registerReceiver(mAnimationProvider, filter);

        IntentFilter scrollFilter = new IntentFilter();
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_START);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_CLOSE);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_CLEAR_IMAGE_CACHE);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_SELECT_ITEM);
        context.registerReceiver(mScrollViewProvider, scrollFilter);
    }",1
WidgetTextfieldInteger.java,/** * @return    The specified value. */,"public int getValue() {
		
		return Integer.parseInt(textfield.getText());
		
	}",1
WidgetTextfieldsOptionalMinMax.java,/** * @return    True if the maximum should be automatic. */,"public boolean isMaximumAutomatic() {
		
		return maxCheckbox.isSelected();
		
	}",1
WidgetUpdater.java,/** * update only the app widgets associated with the given id * @param context * @param dbHelper * @param appWidgetId */,"public static void updateWidget(Context context, AppHistoryDbHelper dbHelper, int appWidgetId) {
		
		log.d(""updating widget for appWidgetId: "" + appWidgetId);
		
		AppWidgetManager manager = AppWidgetManager.getInstance(context);
		RemoteViews updateViews = buildUpdate(context, dbHelper, appWidgetId);
		if (updateViews != null) {
			manager.updateAppWidget(appWidgetId, updateViews);
		}
	}",1
WidgetUtils.java,/** * * @param control which index should be found * @return index of control */,"public static int getIndex(Control control) {
		// This is the reverse method of
		//    Matcher matcher = allOf(widgetOfType(Button.class), withStyle(SWT.PUSH, ""SWT.PUSH""));
		//    return new SWTBotButton((Button) widget(matcher, index), matcher);
		// TODO? Evaluate reusing matchers here too

		int index = 0;
		Composite parent = null;
		do {
			parent = control.getParent();
			for (Control c : parent.getChildren()) {
				if(c.equals(control)){
					return index;
				} else if (c.getClass().equals(control.getClass())){
					index++;
				}
			}
		} while(!(parent instanceof Shell));

		throw new RuntimeException(""Could not determine index for widget "" + control);
	}",1
WidgetUtils.java,/** * * @param widget which parent shell should be found * @return shell which contains widget or null */,"public static Shell getShell(Control widget) {
		while (widget != null) {
			if (widget instanceof Shell) {
				return ((Shell)widget);
			} else {
				widget = ((Control)widget).getParent();
			}
		}
		return null;
	}",1
WiffConnection.java,/** * @param packet *          a packet object describing this TCP packet * @throws Exception */,"public WiffConnection(WiffPacket packet) throws Exception {
    sourceIp = packet.getSourceIP();
    sourcePort = packet.getSourcePort();
    destinationIp = packet.getDestinationIP();
    destinationPort = packet.getDestinationPort();
  }",1
WiffPacket.java,/** * @return the source ip */,"public int getSourceIPAsInt() {
    return getUInt(source());
  }",1
WiffPacket.java,/** * @return the source port */,"public int getSourcePort() {
    int offset = getEthHeaderLength() + getIpHeaderLength();

    byte[] bytes = new byte[2];
    buffer.clear().position(offset).limit(offset + 2);
    buffer.get(bytes);

    return getUShortAsUInt(bytes);
  }",1
WiffPacket.java,/** * @return the destination port */,"public int getDestinationPort() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 2;

    byte[] bytes = new byte[2];
    buffer.clear().position(offset).limit(offset + 2);
    buffer.get(bytes);

    return getUShortAsUInt(bytes);
  }",1
WiffPacket.java,/** * @return the packet's sequence number */,"public long getSequenceNumber() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 4;

    byte[] bytes = new byte[4];
    buffer.clear().position(offset).limit(offset + 4);
    buffer.get(bytes);

    return getULong(bytes);
  }",1
WiffPacket.java,/** * @return true if the packet's SYN flag is raised */,"public boolean isSyn() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 13;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0x02) == 0x02;
  }",1
WiffProperties.java,/** * Retrieves the value of the given key as an int * * @param key *          the property to retrieve * @return the key's value as an int */,"public int getInt(String key) {
    return getInt(key, 0);
  }",1
WiffProperties.java,/** * Retrieves the value of the given key as a boolean * * @param key *          the property to retrieve * @return the key's value as a boolean */,"public boolean getBoolean(String key) {
    return Boolean.parseBoolean(getString(key));
  }",1
WiffProperties.java,"/** * Bulk loads the properties object from a map of key, value pairs * * @param map *          a map of keys and values */","public void setProperities(Map<String, String> map) {
    for (String key : map.keySet()) {
      setProperty(key, map.get(key));
    }
  }",1
WiffProperties.java,"/** * Determines if the given property has a value * * @param key *          the name of the property * @return true if the property has been set. Otherwise, false. */","public boolean contains(String key) {
    return properties.containsKey(key);
  }",1
WiffReporter.java,/** * @return */,"public T getKillPill() {
    return killSignal;
  }",1
WiffReporter.java,/** * Releases resources used by this reporter */,"public void cleanup() {
    messages.clear();
  }",1
WiffReporter.java,/** * Stops the execution of the run method and releases resources. */,"public void stop() {
    running = false;
  }",1
WiffReporter.java,"/** * Determines if this reporter is still active. * * @return true, if this reporter is still active. */","public boolean isRunning() {
    return running;
  }",1
wifiAddresses.java,/** * Gets a list of all clients Ip Addresses connected to the Hotspot from ARP file * @param onlyReachables  false if the list should contain unreachable clients or true otherwise * @return ArrayList of all clients Ip Addresses */,"public ArrayList<String> getArpLiveIps(boolean onlyReachables) {
                BufferedReader bufRead = null;
                ArrayList<String> result = null;
               
                try {
                        result = new ArrayList<String>();
                        bufRead = new BufferedReader(new FileReader(""/proc/net/arp""));
                        String fileLine;
                        while ((fileLine = bufRead.readLine()) != null) {
                        	
                        	 
                                String[] splitted = fileLine.split("" +"");
                                
                                  if ((splitted != null) && (splitted.length >= 4)) {
                                	  
                                        String mac = splitted[3];
                                         if (mac.matches(""..:..:..:..:..:.."")) {
                                              boolean isReachable = pingCmd(splitted[0]);
                                             if (!onlyReachables || isReachable) {
                                                        result.add(splitted[0]);
                                                }
                                        }
                                }
                        }
                } catch (Exception e) {
                       
                } finally {
                        try {
                        	bufRead.close();
                        } catch (IOException e) {
                               
                        }
                }

                return result;
        }",1
WifiDirectHandler.java,/** * Registers a WifiDirectBroadcastReceiver with an IntentFilter listening for P2P Actions */,"public void registerP2pReceiver() {
        p2pBroadcastReceiver = new WifiDirectBroadcastReceiver();
        IntentFilter intentFilter = new IntentFilter();

        // Indicates a change in the list of available peers
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
        // Indicates a change in the Wi-Fi P2P status
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        // Indicates the state of Wi-Fi P2P connectivity has changed
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
        // Indicates this device's details have changed.
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);

        registerReceiver(p2pBroadcastReceiver, intentFilter);
        Log.i(TAG, ""P2P BroadcastReceiver registered"");
    }",1
WifiDirectHandler.java,/** * Unregisters the WifiDirectBroadcastReceiver and IntentFilter */,"public void unregisterP2pReceiver() {
        if (p2pBroadcastReceiver != null) {
            unregisterReceiver(p2pBroadcastReceiver);
            p2pBroadcastReceiver = null;
            Log.i(TAG, ""P2P BroadcastReceiver unregistered"");
        }
    }",1
WifiDirectHandler.java,"/** * Removes persistent/remembered groups * * Source: https://android.googlesource.com/platform/cts/+/jb-mr1-dev%5E1%5E2..jb-mr1-dev%5E1/ * Author: Nick  Kralevich <nnk@google.com> * * WifiP2pManager.java has a method deletePersistentGroup(), but it is not accessible in the * SDK. According to Vinit Deshpande <vinitd@google.com>, it is a common Android paradigm to * expose certain APIs in the SDK and hide others. This allows Android to maintain stability and * security. As a workaround, this removePersistentGroups() method uses Java reflection to call * the hidden method. We can list all the methods in WifiP2pManager and invoke ""deletePersistentGroup"" * if it exists. This is used to remove all possible persistent/remembered groups. */","private void removePersistentGroups() {
        try {
            Method[] methods = WifiP2pManager.class.getMethods();
            for (int i = 0; i < methods.length; i++) {
                if (methods[i].getName().equals(""deletePersistentGroup"")) {
                    // Remove any persistent group
                    for (int netid = 0; netid < 32; netid++) {
                        methods[i].invoke(wifiP2pManager, channel, netid, null);
                    }
                }
            }
            Log.i(TAG, ""Persistent groups removed"");
        } catch(Exception e) {
            Log.e(TAG, ""Failure removing persistent groups: "" + e.getMessage());
            e.printStackTrace();
        }
    }",1
WifiDirectHandler.java,/** * Initiates a service discovery. This has a 2 minute timeout. To continuously * discover services use continuouslyDiscoverServices */,"public void discoverServices(){
        // Initiates service discovery. Starts to scan for services we want to connect to
        wifiP2pManager.discoverServices(channel, new WifiP2pManager.ActionListener() {
            @Override
            public void onSuccess() {
                Log.i(TAG, ""Service discovery initiated"");
            }

            @Override
            public void onFailure(int reason) {
                Log.e(TAG, ""Failure initiating service discovery: "" + FailureReason.fromInteger(reason).toString());
            }
        });
    }",1
WifiDirectHandler.java,/** * Calls initial services discovery call and submits the first * Discover task. This will continue until stopDiscoveringServices is called */,"public void continuouslyDiscoverServices(){
        Log.i(TAG, ""Continuously Discover services called"");

        if (serviceDiscoveryRegistered == false) {
            Log.i(TAG, ""Setting up service discovery"");
            registerServiceDiscoveryListeners();
            serviceDiscoveryRegistered = true;
        }

        // TODO Change this to give some sort of status
        if (isDiscovering){
            Log.w(TAG, ""Services are still discovering, do not need to make this call"");
        } else {
            addServiceDiscoveryRequest();
            isDiscovering = true;
            // List to track discovery tasks in progress
            serviceDiscoveryTasks = new ArrayList<>();
            // Make discover call and first discover task submission
            discoverServices();
            submitServiceDiscoveryTask();
        }
    }",1
WifiDirectHandler.java,/** * Removes a registered local service. */,"public void removeService() {
        if(wifiP2pServiceInfo != null) {
            Log.i(TAG, ""Removing local service"");
            wifiP2pManager.removeLocalService(channel, wifiP2pServiceInfo, new WifiP2pManager.ActionListener() {
                @Override
                public void onSuccess() {
                    wifiP2pServiceInfo = null;
                    Intent intent = new Intent(Action.SERVICE_REMOVED);
                    localBroadcastManager.sendBroadcast(intent);
                    Log.i(TAG, ""Local service removed"");
                }

                @Override
                public void onFailure(int reason) {
                    Log.e(TAG, ""Failure removing local service: "" + FailureReason.fromInteger(reason).toString());
                }
            });
            wifiP2pServiceInfo = null;
        } else {
            Log.w(TAG, ""No local service to remove"");
        }
    }",1
WifiDirectHandler.java,/** * Initiates a connection to a service * @param service The service to connect to */,"public void initiateConnectToService(DnsSdService service) {
        // Device info of peer to connect to
        WifiP2pConfig wifiP2pConfig = new WifiP2pConfig();
        wifiP2pConfig.deviceAddress = service.getSrcDevice().deviceAddress;
        wifiP2pConfig.wps.setup = WpsInfo.PBC;

        // Starts a peer-to-peer connection with a device with the specified configuration
        wifiP2pManager.connect(channel, wifiP2pConfig, new WifiP2pManager.ActionListener() {
            // The ActionListener only notifies that initiation of connection has succeeded or failed

            @Override
            public void onSuccess() {
                Log.i(TAG, ""Initiating connection to service"");
            }

            @Override
            public void onFailure(int reason) {
                Log.e(TAG, ""Failure initiating connection to service: "" + FailureReason.fromInteger(reason).toString());
            }
        });
    }",1
WifiDirectHandler.java,/** * Translates a device status code to a readable String status * @param status * @return A readable String device status */,"public String deviceStatusToString(int status) {
        if (status == WifiP2pDevice.AVAILABLE) {
            return ""Available"";
        } else if (status == WifiP2pDevice.INVITED) {
            return ""Invited"";
        } else if (status == WifiP2pDevice.CONNECTED) {
            return ""Connected"";
        } else if (status == WifiP2pDevice.FAILED) {
            return ""Failed"";
        } else if (status == WifiP2pDevice.UNAVAILABLE) {
            return ""Unavailable"";
        } else {
            return ""Unknown"";
        }
    }",1
wifiHotSpots.java,/** * Check if The Device Is Connected to Hotspot using wifi * * @return true if device connect to Hotspot */,"public boolean  isConnectedToAP(){
		ConnectivityManager connectivity = (ConnectivityManager)mContext
		        .getSystemService(Context.CONNECTIVITY_SERVICE);
		if (connectivity != null) {
		    NetworkInfo info = connectivity.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
		    if (info != null) {
		        if (info.isConnected()) {
			            return true;
		        }
		    }
		}
		return false;
	}",1
wifiHotSpots.java,/** * get Connection Info * @return WifiInfo */,"public WifiInfo getConnectionInfo() {
        return mWifiManager.getConnectionInfo();
    }",1
WifiStatus.java,/** * Method to Check if the Device Support  Wifi or not * * @return true if Wifi supported or false if Wifi not supported */,"public boolean isSupportWifi() {
		    PackageManager pm = mContext.getPackageManager();
		    if (pm.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
		        return true;
		    } else {
		        return false;
		    }
		}",1
WifiStatus.java,/** * Method to Check if wifi is enabled * * @return true if wifi enabled or false if wifi Disabled */,"public boolean istWifiEnabled() {
			if (!mWifiManager.isWifiEnabled() ) {
				  return false;
			 }else{
			      return true;  	   
			  }
	  }",1
WifiStatus.java,/** * Check if The Device Is Connected to Hotspot using wifi * * @return true if device connect to Hotspot or return false if not */,"public boolean  isConnectedToAP(){
			ConnectivityManager connectivity = (ConnectivityManager)mContext
			        .getSystemService(Context.CONNECTIVITY_SERVICE);
			if (connectivity != null) {
			    NetworkInfo info = connectivity.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
			    if (info != null) {
			        if (info.isConnected()) {
				            return true;
			        }
			    }
			}
			return false;
		}",1
WifiStatus.java,/** * check if  Mobile Data With SIM Enabled */,"public boolean isMobileDataEnabled() {
            try {
                ConnectivityManager connectivityManager = (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                Method method = connectivityManager.getClass().getMethod(""getMobileDataEnabled"");
                return (Boolean)method.invoke(connectivityManager);
            } catch (Exception e) {
                e.printStackTrace();
            }

            return false;
        }",1
WikiLoader.java,/** * Visit a block and returns the list of substitutions that must be performed in the visited block. The returned list * can be safely modified. * * @param block the block to visit * @param currentSyntaxId the current syntax is * @return the substitution list */,"private List<Substitution> visit(Block block, String currentSyntaxId)
   {
      return visit(block, 0, currentSyntaxId);
   }",1
WikipediaExample.java,"/** * this will lazily continue searches, making new http calls as necessary. * * @param wikipedia used to search * @param query     see {@link Wikipedia#search(String)}. */","static Iterator<Page> lazySearch(final Wikipedia wikipedia, final String query) {
    final Response<Page> first = wikipedia.search(query);
    if (first.nextOffset == null) {
      return first.iterator();
    }
    return new Iterator<Page>() {
      Iterator<Page> current = first.iterator();
      Long nextOffset = first.nextOffset;

      @Override
      public boolean hasNext() {
        while (!current.hasNext() && nextOffset != null) {
          System.out.println(""Wow.. even more results than "" + nextOffset);
          Response<Page> nextPage = wikipedia.resumeSearch(query, nextOffset);
          current = nextPage.iterator();
          nextOffset = nextPage.nextOffset;
        }
        return current.hasNext();
      }

      @Override
      public Page next() {
        return current.next();
      }

      @Override
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }",1
WikiUtil.java,/** * Return an unique UUID and initial it in repository. * @param spacename * @param username * @param password * @param repositoryService * @return * @throws PageException */,"public static String createPageUuid(String spacename, String username, String password, RepositoryService repositoryService) throws PageException{
		//DON'T user repository created UUID for future export/import function:
		//always keep page UUID unchanged whatever import to any new database
		//UUID.randomUUID().toString(); - use smaller string to replace 32 length UUID, I test possible duplicated case
		//if it is case sensitive, it is almost impossible duplicated even 50 million. But I have to make to lowerCase 
		// 1 million no duplicate, but 50 million will have 9 duplicate -- this make need make duplciate try-catch check?
		String uuid = RandomStringUtils.randomAlphanumeric(WikiConstants.UUID_KEY_SIZE).toLowerCase();
		try {
			ITicket ticket = repositoryService.login(spacename,username, password);
			repositoryService.createIdentifier(ticket,RepositoryService.TYPE_ATTACHMENT, uuid);
		} catch (RepositoryException e) {
			log.error(""Create page UUID failed request from repository :"" , e);
			throw new PageException(e);
		} catch (RepositoryTiemoutExcetpion e) {
			log.error(""Create page UUID failed request from repository :"" , e);
			throw new PageException(e);
		}
		
		return uuid;
	}",1
WikiUtil.java,"/** * GWT use anchor to do ajax call. such as #token. * Basically, this is same with javascript location.href=token. location.href will do encoding to token. * But this encoding has some different with URL encoding. This method will encode string to location.href encoding * * Normally,Different list<br> * Space: URL=+ ; Anchor=%20 * * But system use special entity replace to replace some keywords, include +. * * @param token * @return */","public static String encodeURL(String token) {
		try {
			//replace token keyword #,@,>,+ etc to entity
			token = EscapeUtil.escapeToken(token);
			token = URLEncoder.encode(token, Constants.UTF8);
		} catch (UnsupportedEncodingException e) {
			WebUtil.log.error(""Encode token failed."",e);
		}
		return token;
	}",1
WikiUtil.java,/** * @param page * @return */,"public static boolean isHomepage(AbstractPage page) {
		return page.equals(page.getSpace().getHomepage());
	}",1
WikiUtil.java,/** * @return System administrator notification web page URL */,"public static String getSystemAdminTokenLink() {
		return new StringBuffer(WebUtil.getHostAppURL()).append(SharedConstants.URL_PAGE).append(""#"")
		.append(GwtUtils.getCPageToken(SharedConstants.CPAGE_SYSADMIN_NOTIFY)).toString();
	}",1
WildcardTypeName.java,"/** * Returns a type that represents an unknown type that extends {@code bound}. For example, if * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code * ? extends Object}. */","public static WildcardTypeName subtypeOf(TypeName upperBound) {
    return new WildcardTypeName(Arrays.asList(upperBound), Collections.<TypeName>emptyList());
  }",1
Win.java,/** * Indicates that the annotated code is win. For example: * <p/> * <pre> *   &#064;Win(Outcome.INCONCEIVABLE) *   public class BaconExplosion { * </pre> */,"@Documented
@Retention(RetentionPolicy.RUNTIME)
@Visionary(""Hanneli"")
public @interface Win {
    Outcome value() default Outcome.EPIC;
}",1
Win32PrintJob.java,"/** * updates a Paper object to reflect the current printer's selected * paper size and imageable area for that paper size. * Default implementation copies settings from the original, applies * applies some validity checks, changes them only if they are * clearly unreasonable, then sets them into the new Paper. * Subclasses are expected to override this method to make more * informed decisons. */","protected void validatePaper(Paper origPaper, Paper newPaper) {
        if (origPaper == null || newPaper == null) {
            return;
        } else {
            double wid = origPaper.getWidth();
            double hgt = origPaper.getHeight();
            double ix = origPaper.getImageableX();
            double iy = origPaper.getImageableY();
            double iw = origPaper.getImageableWidth();
            double ih = origPaper.getImageableHeight();

            /* Assume any +ve values are legal. Overall paper dimensions
             * take precedence. Make sure imageable area fits on the paper.
             */
            Paper defaultPaper = new Paper();
            wid = ((wid > 0.0) ? wid : defaultPaper.getWidth());
            hgt = ((hgt > 0.0) ? hgt : defaultPaper.getHeight());
            ix = ((ix > 0.0) ? ix : defaultPaper.getImageableX());
            iy = ((iy > 0.0) ? iy : defaultPaper.getImageableY());
            iw = ((iw > 0.0) ? iw : defaultPaper.getImageableWidth());
            ih = ((ih > 0.0) ? ih : defaultPaper.getImageableHeight());
            /* full width/height is not likely to be imageable, but since we
             * don't know the limits we have to allow it
             */
            if (iw > wid) {
                iw = wid;
            }
            if (ih > hgt) {
                ih = hgt;
            }
            if ((ix + iw) > wid) {
                ix = wid - iw;
            }
            if ((iy + ih) > hgt) {
                iy = hgt - ih;
            }
            newPaper.setSize(wid, hgt);
            newPaper.setImageableArea(ix, iy, iw, ih);
        }
    }",1
Win32PrintJob.java,/** * Converts the Java 1/72 inch to .NET 1/100 inch * @param javaLength the java length in 1/72 inch * @return the .NET length in 1/100 inch */,"private static int java2netLength( int javaLength ){
    	return (int) Math.round( (double)(javaLength * 100) / 72d );
    }",1
Win32Utils.java,/** * Determines the location of the AppData/Roaming folder */,"public static String determineAppDataDir()
    {
        String appDataDir = null;

        // Modified from http://stackoverflow.com/questions/5953149/detect-the-location-of-appdata-locallow-with-jna
        final PointerByReference ppszPath = new PointerByReference();

        int hResult = Shell32.INSTANCE.SHGetKnownFolderPath(
                Shell32.FOLDERID_RoamingAppData,
                Shell32.KF_FLAG_CREATE, null, ppszPath);

        if (Shell32.S_OK == hResult) {
            try {
                appDataDir = nullTerminatedToString(ppszPath);
            } finally {
                Ole32.INSTANCE.CoTaskMemFree(ppszPath.getValue());
            }
        } else {
            logger.log(Level.SEVERE, null, ""Could not determine local application data directory: "" + hResult);
        }

        return appDataDir;
    }",1
WindowCache.java,"/** * Returns the size of the {@link #sWindows} cache. * * @param cls The class of the implementation of the window. * @return True if the cache corresponding to this class is empty, false if * it is not empty. */","public int getCacheSize(Class<? extends StandOutWindow> cls) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 == null) {
            return 0;
        }

        return l2.size();
    }",1
WindowCompat.java,"/** * Flag for specifying the behavior of action modes when an Action Bar is not present. * If overlay is enabled, the action mode UI will be allowed to cover existing window content. */","public static final int FEATURE_ACTION_MODE_OVERLAY = 10;
}
}",1
WindowFunctions.java,/** * Creates a Blackman Window. * Code from https://www.ee.columbia.edu/~ronw/code/MEAPsoft/doc/html/FFT_8java-source.html * All credit goes to the original authors! * * @param ntabs number of samples * @return window samples */,"public static float[] makeBlackmanWindow(int ntabs) {
		// Make a blackman window:
		// w(n)=0.42-0.5cos{(2*PI*n)/(N-1)}+0.08cos{(4*PI*n)/(N-1)};
		float[] window = new float[ntabs];
		for (int i = 0; i < window.length; i++)
			window[i] = 0.42f - 0.5f * (float)Math.cos(2 * Math.PI * i / (ntabs - 1))
					+ 0.08f * (float)Math.cos(4 * Math.PI * i / (ntabs - 1));
		return window;
	}",1
WindowHoverMenu.java,"/** * Expands the Hover menu to show all of its tabs and a content area for the selected tab. To * collapse the menu down a single active tab, use {@link #collapseMenu()}. */","@Override
    public void expandMenu() {
        if (mIsInDragMode) {
            mHoverMenuView.expand();
        }
    }",1
WindowInstances.java,/** * <p>haveSameSubject.</p> * * @param t1 a {@link lupos.datastructures.items.Triple} object. * @param t2 a {@link lupos.datastructures.items.Triple} object. * @return a boolean. */,"protected boolean haveSameSubject(Triple t1, Triple t2) {
		if(t1==null || t2==null){
			return false;
		}
		return 0==t1.getSubject().compareToNotNecessarilySPARQLSpecificationConform(t2.getSubject());
	}",1
WindowInstances.java,/** * <p>deleteInstanceDebug.</p> * * @param t a {@link lupos.datastructures.items.Triple} object. * @param debugstep a {@link lupos.misc.debug.DebugStep} object. */,"protected void deleteInstanceDebug(Triple t, DebugStep debugstep) {
		// 1. search for triples with same subject
		List<TimestampedTriple> instanceTriples = new ArrayList<TimestampedTriple>();
		for(TimestampedTriple tmp : this.tripleBuffer) {
			if(haveSameSubject(tmp,t)){
				instanceTriples.add(tmp);
			}
		}
		// 2. delete them
		for(TimestampedTriple tmp : instanceTriples) {
			this.tripleBuffer.remove(tmp);
			super.deleteTripleDebug(tmp, debugstep);
		}
	}",1
WindowInstancesNumber.java,/** * <p>Constructor for WindowInstancesNumber.</p> * * @param numberOfInstances a int. * @param instanceClass a {@link lupos.datastructures.items.literal.Literal} object. */,"public WindowInstancesNumber(final int numberOfInstances, Literal instanceClass) {
		super(instanceClass);
		if (numberOfInstances < 1) {
			System.err.println(""X must be >=1 for WINDOW TYPE SLIDINGTRIPLES X"");
			System.err.println(""Assuming WINDOW TYPE SLIDINGTRIPLES 1..."");
			this.numberOfInstances = 1;
		} else
			this.numberOfInstances = numberOfInstances;		
	}",1
WindowManagerService.java,/** * Check wallpaper for visiblity change and notify window if so. * @param wallpaper The wallpaper to test and notify. * @param visible Current visibility. */,"void dispatchWallpaperVisibility(final WindowState wallpaper, final boolean visible) {
        if (wallpaper.mWallpaperVisible != visible) {
            wallpaper.mWallpaperVisible = visible;
            try {
                if (DEBUG_VISIBILITY || DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
                        ""Updating vis of wallpaper "" + wallpaper
                        + "": "" + visible + "" from:\n"" + Debug.getCallers(4, ""  ""));
                wallpaper.mClient.dispatchAppVisibility(visible);
            } catch (RemoteException e) {
            }
        }
    }",1
WindowManagerService.java,"/** * Thaw rotation changes.  (Disable ""rotation lock"".) * Persists across reboots. */","@Override
    public void thawRotation() {
        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
                ""thawRotation()"")) {
            throw new SecurityException(""Requires SET_ORIENTATION permission"");
        }

        if (DEBUG_ORIENTATION) Slog.v(TAG, ""thawRotation: mRotation="" + mRotation);

        long origId = Binder.clearCallingIdentity();
        try {
            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE,
                    777); // rot not used
        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        updateRotationUnchecked(false, false);
    }",1
WindowManagerService.java,"/** * Starts the view server on the specified port. * * @param port The port to listener to. * * @return True if the server was successfully started, false otherwise. * * @see com.android.server.wm.ViewServer * @see com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT */","@Override
    public boolean startViewServer(int port) {
        if (isSystemSecure()) {
            return false;
        }

        if (!checkCallingPermission(Manifest.permission.DUMP, ""startViewServer"")) {
            return false;
        }

        if (port < 1024) {
            return false;
        }

        if (mViewServer != null) {
            if (!mViewServer.isRunning()) {
                try {
                    return mViewServer.start();
                } catch (IOException e) {
                    Slog.w(TAG, ""View server did not start"");
                }
            }
            return false;
        }

        try {
            mViewServer = new ViewServer(this, port);
            return mViewServer.start();
        } catch (IOException e) {
            Slog.w(TAG, ""View server did not start"");
        }
        return false;
    }",1
WindowManagerService.java,"/** * Returns the focused window in the following format: * windowHashCodeInHexadecimal windowName * * @param client The remote client to send the listing to. * @return False if an error occurred, true otherwise. */","boolean viewServerGetFocusedWindow(Socket client) {
        if (isSystemSecure()) {
            return false;
        }

        boolean result = true;

        WindowState focusedWindow = getFocusedWindow();

        BufferedWriter out = null;

        // Any uncaught exception will crash the system process
        try {
            OutputStream clientStream = client.getOutputStream();
            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);

            if(focusedWindow != null) {
                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));
                out.write(' ');
                out.append(focusedWindow.mAttrs.getTitle());
            }
            out.write('\n');
            out.flush();
        } catch (Exception e) {
            result = false;
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    result = false;
                }
            }
        }

        return result;
    }",1
WindowManagerService.java,"/** * Return the list of WindowStates associated on the passed display. * @param display The screen to return windows from. * @return The list of WindowStates on the screen, or null if the there is no screen. */","public WindowList getWindowListLocked(final Display display) {
        return getWindowListLocked(display.getDisplayId());
    }",1
WindowNets.java,/** * Fills the list with the nets in the net list. */,"protected void fill_list()
    {
        Nets nets = this.board_frame.board_panel.board_handling.get_routing_board().rules.nets;
        Net[] sorted_arr = new Net[nets.max_net_no()];
        for (int i = 0; i < sorted_arr.length; ++i)
        {
            sorted_arr[i] = nets.get(i + 1);
        }
        java.util.Arrays.sort(sorted_arr);
        for (int i = 0; i < sorted_arr.length; ++i)
        {
            this.add_to_list(sorted_arr[i]);
        }
        this.list.setVisibleRowCount(Math.min(sorted_arr.length, DEFAULT_TABLE_SIZE));
    }",1
WindowParam.java,/** * * set Y coordinate of the left upper point of the window * **/,"public void setTopRightCornerY(int topRightCornerY) {
		this.topRightCornerY = topRightCornerY;
	}",1
WindowsRealm.java,/** * Returns a simple username without any domain prefixes. * * @param username * @return a simple username */,"private String getSimpleUsername(String username) {
        String simpleUsername = username;
        if (defaultDomain != null) {
            // sanitize username
            if (username.startsWith(defaultDomain + ""\\"")) {
                // strip default domain from domain\ username
                simpleUsername = username.substring(defaultDomain.length() + 1);
            } else if (username.endsWith(""@"" + defaultDomain)) {
                // strip default domain from username@domain
                simpleUsername = username.substring(0, username.lastIndexOf('@'));
            }
        }
        return simpleUsername;
    }",1
WinProxySearchStrategy.java,/************************************************************************* * getProxySelector * * @see com.github.markusbernhardt.proxy.ProxySearchStrategy#getProxySelector() ************************************************************************/,"@Override
	public ProxySelector getProxySelector() throws ProxyException {
		// TODO Rossi 08.05.2009 Implement this by using Win API calls.
		// new Win32ProxyUtils().winHttpGetDefaultProxyConfiguration()
		// Current fallback is to use the IE settings. This is better
		// because the registry settings are most of the time not set.
		// Some Windows server installations may use it though.
		return new IEProxySearchStrategy().getProxySelector();
	}",1
WinSrvPlugin.java,/** * Return a File pointing to the location of the Jar file this Main method is executed from. * @return */,"public File getWarLocation() {
        URL resource = WinSrvPlugin.class.getResource(""/META-INF/jettyconsole/jettyconsole.properties"");
        String file = resource.getFile();
        file = file.substring(""file:"".length(), file.indexOf(""!""));
        try {
            file = URLDecoder.decode(file, ""utf-8"");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        return new File(file);
    }",1
WinstoneResponse.java,/** * @deprecated */,"@Deprecated
	@Override
	public String encodeUrl(final String url) {
		return encodeURL(url);
	}",1
WintInnerHackBase64.java,"/** * Tests a given byte array to see if it contains * only valid characters within the WintInnerHackBase64 alphabet. * * @param arrayOctect byte array to test * @return true if all bytes are valid characters in the WintInnerHackBase64 *         alphabet or if the byte array is empty; false, otherwise */","public static boolean isArrayByteBase64(byte[] arrayOctect) {

        arrayOctect = discardWhitespace(arrayOctect);

        int length = arrayOctect.length;
        if (length == 0) {
            // shouldn't a 0 length array be valid base64 data?
            // return false;
            return true;
        }
        for (int i = 0; i < length; i++) {
            if (!isBase64(arrayOctect[i])) {
                return false;
            }
        }
        return true;
    }",1
WintInnerHackBase64.java,"/** * Discards any characters outside of the base64 alphabet, per * the requirements on page 25 of RFC 2045 - ""Any characters * outside of the base64 alphabet are to be ignored in base64 * encoded data."" * * @param data The base-64 encoded data to groom * @return The data, less non-base64 characters (see RFC 2045). */","static byte[] discardNonBase64(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (int i = 0; i < data.length; i++) {
            if (isBase64(data[i])) {
                groomedData[bytesCopied++] = data[i];
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }",1
WireMillRecipes.java,"/** * Adds a drawing recipe. * * @param input *            As an ItemStack * @param output *            As an ItemStack * @param ticks *            The ticks required for the recipe, seconds * 20. */","public void addProcessing(ItemStack input, ItemStack output, int ticks)
    {
        try
        {
            if (input != null && output != null && ticks > 0)
            {
                int nextRecipeID = this.recipeToOutput.size();
                this.inputToRecipe.put(stackSizeToOne(input) + """", nextRecipeID);
                this.recipeToInput.put(nextRecipeID, stackSizeToOne(input));
                this.recipeToOutput.put(nextRecipeID, output);
                this.recipeToTicks.put(nextRecipeID, ticks);
                this.recipeToInputQTY.put(nextRecipeID, input.stackSize);
            }
            else if (input == null)
                throw new IOException(""Error: Input cannot be null."");
            else if (output == null)
                throw new IOException(""Error: Output cannot be null."");
            else if (ticks <= 0)
                throw new IOException(""Error: Ticks must be greater than 0."");
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }",1
WireMockActivityInstrumentationTestCase2.java,/** * Test WireMock */,"@Test
    public void testWiremock() {
        activity = activityRule.getActivity();
        String jsonBody = asset(activity, ""atlanta-conditions.json"");
        stubFor(get(urlMatching(""/api/.*""))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = ""http://127.0.0.1:"" + BuildConfig.PORT;
        logger.debug(""WireMock Endpoint: "" + serviceEndpoint);
        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));

        onView(ViewMatchers.withId(R.id.editText)).perform(typeText(""atlanta""));
        onView(withId(R.id.button)).perform(click());
        onView(withId(R.id.textView)).check(matches(withText(containsString(""GA""))));
    }",1
WireMockAndroidTest1.java,/** * Test WireMock */,"@Test
    public void testWiremock() {
        Context applicationContext = InstrumentationRegistry.getTargetContext().getApplicationContext();
        activity = activityRule.launchActivity(new Intent(applicationContext, MainActivity.class));
        String jsonBody = asset(activity, ""atlanta-conditions.json"");
        stubFor(get(urlMatching(""/api/.*""))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = ""http://127.0.0.1:"" + BuildConfig.PORT;
        logger.debug(""WireMock Endpoint: "" + serviceEndpoint);
        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));

        onView(ViewMatchers.withId(R.id.editText)).perform(typeText(""atlanta""));
        onView(withId(R.id.button)).perform(click());
        onView(withId(R.id.textView)).check(matches(withText(containsString(""GA""))));
    }",1
WishListResource.java,/** * GET  /wish-lists : get all the wishLists. * * @return the ResponseEntity with status 200 (OK) and the list of wishLists in body */,"@GetMapping(""/wish-lists"")
    @Timed
    public List<WishList> getAllWishLists() {
        log.debug(""REST request to get all WishLists"");
        List<WishList> wishLists = wishListRepository.findAll();
        return wishLists;
    }",1
WishResource.java,"/** * GET  /wishes/:id : get the ""id"" wish. * * @param id the id of the wish to retrieve * @return the ResponseEntity with status 200 (OK) and with body the wish, or with status 404 (Not Found) */","@GetMapping(""/wishes/{id}"")
    @Timed
    public ResponseEntity<Wish> getWish(@PathVariable Long id) {
        log.debug(""REST request to get Wish : {}"", id);
        Wish wish = wishService.findOne(id);
        return Optional.ofNullable(wish)
            .map(result -> new ResponseEntity<>(
                result,
                HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }",1
WithEntityManager.java,"/** * Use this annotation when not using the default entity manager. If there are more than one, * CDI Query needs to know which one to use for a specific DAO. * * @author thomashug */","@Target(TYPE)
@Retention(RUNTIME)
@Documented
@Inherited
public @interface WithEntityManager {
    Class<? extends Annotation>[] value();
}
}",1
WithinCircleQueryPredicate.java,/** * This predicate returns {@code true} if a {@link io.sphere.sdk.models.GeoJSON} object * is within the circle given by the center and radius in meters. * * @param <T> the type for which this predicate can be instantiated */,"class WithinCircleQueryPredicate<T> extends QueryModelQueryPredicate<T> {
    private final Point center;
    private final Double radius;

    WithinCircleQueryPredicate(final QueryModel<T> queryModel, final Point center, final Double radius) {
        super(queryModel);
        this.center = center;
        this.radius = radius;
    }

    @Override
    protected String render() {
        return String.format("" within circle(%f, %f, %f)"", center.getLongitude(), center.getLatitude(), radius);
    }
}",1
WithLongPressFragment.java,"/** * create a view from resource Xml file, and hold the view that may be used in displaying data. * * @param layoutInflater */","@Override
        public View createView(LayoutInflater layoutInflater) {
            View view = layoutInflater.inflate(R.layout.with_long_press_list_view_item, null);
            mImageView = (CubeImageView) view.findViewById(R.id.with_long_press_list_image);
            return view;
        }",1
WithModuleFactory.java,"/** * Marks a screen as defining a {@link MortarScope}, with a factory class to * create its Dagger module. * * @see WithModule * @see ScreenScoper */","@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface WithModuleFactory {
  Class<? extends ModuleFactory> value();
}
}",1
WizardExportResourcesPage2.java,/** * Returns the resource extensions currently specified to be exported. * @return the resource extensions currently specified to be exported (element type: <code>String</code>) */,"protected List getTypesToExport() {

		return selectedTypes;
	}",1
WizardExportResourcesPage2.java,/** * Returns whether the extension of the given resource name is an extension that has been specified for export by * the user. * @param resourceName *            the resource name * @return <code>true</code> if the resource name is suitable for export based upon its extension */,"protected boolean hasExportableExtension(String resourceName) {
		if (selectedTypes == null) {
			return true;
		}

		int separatorIndex = resourceName.lastIndexOf("".""); //$NON-NLS-1$
		if (separatorIndex == -1) {
			return false;
		}

		String extension = resourceName.substring(separatorIndex + 1);

		Iterator it = selectedTypes.iterator();
		while (it.hasNext()) {
			if (extension.equalsIgnoreCase((String) it.next())) {
				return true;
			}
		}

		return false;
	}",1
WizPurchase.java,/** * Remove a purchase from pending purchases' list * * @param purchase Purchase to unset as pending **/,"void unsetPurchaseAsPending(Purchase purchase) {
		SharedPreferences pendingPurchasesCache = cordova.getActivity().getSharedPreferences(PENDING_PURCHASES_CACHE_NAME, 0);
		SharedPreferences.Editor editor = pendingPurchasesCache.edit();
		editor.remove(purchase.getSku());
		editor.commit();
	}",1
WizPurchase.java,/** * Convert a List of Purchase objects in Java-land to an array of JSON Purchase objects to be returned to JS-land * * @param purchase List of purchases to transform to a JSON array **/,"JSONArray convertToJSONArray(List<Purchase> purchaseList) throws JSONException {
		// Convert the java list to JSON
		JSONArray jsonPurchaseList = new JSONArray();
		// Iterate all products
		for (Purchase p : purchaseList) {
			jsonPurchaseList.put(convertToJSONObject(p));
		}
		// Return the JSON list
		return jsonPurchaseList;
	}",1
